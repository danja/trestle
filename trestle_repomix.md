This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-01T22:03:07.082Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

Additional Info:
----------------
User Provided Header:
-----------------------
Trestle Source Code

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
src/
  core/
    errors/
      error-types.js
  css/
    trestle.css
  domain/
    rdf/
      RDFModel.js
  html/
    index.html
  js/
    controller/
      TrestleController.js
    model/
      TrestleModel.js
      TrestleRDFModel.js
    utils/
      EventBus.js
      utils.js
    view/
      TrestleView.js
    config.js
    main.js
  utils/
    utils.js
.gitignore
jasmine.json
jsdoc.json
LICENSE
package.json
README.md
webpack.config.js

================================================================
Files
================================================================

================
File: src/core/errors/error-types.js
================
export class RDFError extends Error {






    constructor(message, details = {}) {
        super(message)
        this.name = 'RDFError'
        this.details = details


        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, RDFError)
        }
    }
}




export class ModelError extends Error {




    constructor(message, details = {}) {
        super(message)
        this.name = 'ModelError'
        this.details = details


        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, ModelError)
        }
    }
}

================
File: src/css/trestle.css
================
:root {
    --primary-color: #3a7ca5;
    --secondary-color: #555;
    --highlight-color: #f5f7fa;
    --background-color: #fff;
    --border-color: #eaeaea;
    --selected-bg: #e1f5fe;
    --selected-border: #4fc3f7;
    --highlight-bg: #f5f5f5;
    --card-header-bg: #3a7ca5;
    --card-header-color: #fff;
    --hover-bg: rgba(0, 0, 0, 0.03);
    --focus-color: #2196f3;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html {
    background-color: var(--highlight-color);
    font-size: 16px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    color: #333;
}

body {
    height: 100vh;
    display: flex;
    flex-direction: column;
}

#header-outer {
    background-color: var(--primary-color);
    color: #fff;
    padding: 0 16px;
    height: 54px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 100;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
}

#header {
    font-size: 1.4rem;
    font-weight: 600;
    letter-spacing: 0.3px;
}

.top-navbar {
    display: flex;
    align-items: center;
}

.top-navbar .toolbar ul {
    display: flex;
    list-style-type: none;
    margin: 0;
    padding: 0;
}

.top-navbar .toolbar li {
    margin: 0 4px;
}

.top-navbar .toolbar button {
    background-color: rgba(255, 255, 255, 0.1);
    color: white;
    border: none;
    border-radius: 4px;
    padding: 6px 12px;
    cursor: pointer;
    font-weight: 500;
    font-size: 0.9rem;
    transition: background-color 0.2s;
}

.top-navbar .toolbar button:hover {
    background-color: rgba(255, 255, 255, 0.2);
}

.hamburger-menu {
    display: none;
    cursor: pointer;
    background: none;
    border: none;
    padding: 10px;
    color: white;
    font-size: 1.5rem;
}

#menu-box {
    position: fixed;
    top: 54px;
    right: 0;
    background-color: white;
    border-radius: 0 0 0 8px;
    padding: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    z-index: 10;
    width: auto;
    left: auto;
}

#menu-box.hidden {
    display: none;
}

#menu-box .toolbar ul {
    list-style-type: none;
    margin: 0;
    padding: 0.2em 0;
}

#menu-box .toolbar li {
    text-align: center;
    margin: 5px;
}

#menu-box .toolbar button {
    width: 130px;
    background-color: #f5f5f5;
    border: 1px solid #eee;
    border-radius: 4px;
    padding: 8px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s;
}

#menu-box .toolbar button:hover {
    background-color: #e0e0e0;
}

#container {
    position: fixed;
    top: 54px;
    left: 0;
    right: 0;
    bottom: 0;
    overflow-y: auto;
    padding: 1.5em;
    background-color: var(--background-color);
    z-index: 1;
}

.page {
    margin: 15px auto;
    max-width: 800px;
}


@media (min-width: 768px) {
    #menu-box {
        display: none !important;
    }

    .top-navbar {
        display: flex;
    }

    .hamburger-menu {
        display: none;
    }
}

@media (max-width: 767px) {
    .top-navbar {
        display: none;
    }

    .hamburger-menu {
        display: block;
    }
}


#trestle {
    display: block;
    margin: 0;
    list-style: none;
    user-select: none;
    font-size: 1rem;
    line-height: 1.5;
}

#trestle ul {
    list-style: none;
    padding-left: 24px;
    margin-left: 4px;
    border-left: 1px solid #eee;
}

#trestle li {
    display: block;
    position: relative;
    margin: 2px 0;
}

.ts-entry {
    position: relative;
    display: flex;
    align-items: center;
    min-height: 28px;
    padding: 4px 0;
    border-radius: 4px;
    transition: background-color 0.15s ease;
}

.ts-entry:hover {
    background-color: var(--hover-bg);
}

.ts-title {
    cursor: text;
    outline: none;
    padding: 3px 6px;
    line-height: 1.5;
    flex-grow: 1;
    border-radius: 3px;
    transition: background-color 0.15s ease;
}

.ts-title:focus {
    background-color: rgba(255, 255, 255, 0.9);
    box-shadow: 0 0 0 2px var(--focus-color);
}

.ts-title:empty::before {
    content: "New item...";
    color: #aaa;
    font-style: italic;
}

.ts-handle {
    visibility: hidden;
    cursor: move;
    color: #777;
    padding: 0 4px;
    font-size: 14px;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.ts-entry:hover .ts-handle {
    visibility: visible;
    opacity: 0.7;
}

.ts-entry .ts-handle:hover {
    opacity: 1;
    color: #444;
}

.ts-actions {
    display: none;
    padding: 0 4px;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.ts-entry:hover .ts-actions {
    display: flex;
    opacity: 0.7;
}

.ts-entry .ts-actions:hover {
    opacity: 1;
}

.ts-actions button {
    background: none;
    border: none;
    cursor: pointer;
    margin: 0 2px;
    padding: 3px;
    font-size: 14px;
    color: #666;
    border-radius: 3px;
    transition: background-color 0.15s ease;
}

.ts-actions button:hover {
    background-color: rgba(0, 0, 0, 0.05);
    color: #555;
}

.ts-expander {
    cursor: pointer;
    width: 20px;
    height: 20px;
    background: none;
    border: none;
    position: relative;
    margin-right: 2px;
    opacity: 0.7;
    transition: opacity 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.ts-expander:hover {
    opacity: 1;
}

.ts-expander::before {
    content: "▾";
    font-size: 11px;
    color: #555;
    font-weight: bold;
}

.ts-closed>.ts-entry>.ts-expander::before {
    content: "▸";
    color: #555;
    font-weight: bold;
}

.ts-closed>ul {
    display: none;
}

.ts-highlight {
    background-color: var(--highlight-bg);
}

.ts-selected {
    background-color: var(--selected-bg);
    border-left: 2px solid var(--selected-border);
}

.ts-selected .ts-title {
    margin-left: -2px;
}

.ts-dragging {
    opacity: 0.5;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    cursor: grabbing;
}

.ts-dragging-item {
    opacity: 0.7;
    position: relative;
    z-index: 5;
}

.ts-dragging-active .ts-handle {
    cursor: grabbing;
}

.dropzone {
    height: 8px;
    background-color: transparent;
    transition: all 0.2s ease;
    border-radius: 4px;
    position: relative;
    z-index: 10;
}

.dropzone.active {
    background-color: rgba(33, 150, 243, 0.3);
    height: 12px;
    border-radius: 4px;
    box-shadow: 0 0 0 1px rgba(33, 150, 243, 0.5) inset;
}


.ts-dragging-active .dropzone {
    border: 1px dashed transparent;
}

.ts-dragging-active .dropzone:hover {
    border-color: rgba(33, 150, 243, 0.5);
    background-color: rgba(33, 150, 243, 0.1);
}

.drag-placeholder {
    border: 1px dashed #aaa;
    background-color: #f9f9f9;
    height: 30px;
    margin: 4px 0;
    border-radius: 4px;
}

[contenteditable="true"]:focus {
    background-color: white;
    outline: none;
}

.text-box {
    background-color: white;
    border-radius: 8px;
    padding: 12px 16px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    line-height: 1.5;
}


.ts-closed:not(:has(ul)) > .ts-entry > .ts-expander::before {
    content: "•";
    opacity: 0.8;
    color: #444;
    font-size: 14px;
}


.ts-add-between {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    opacity: 0;
    height: 20px;
    width: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.2s;
    z-index: 5;
}

.ts-add-between::before {
    content: "+";
    color: #666;
    font-size: 16px;
    background-color: white;
    border-radius: 50%;
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid #ddd;
    font-weight: bold;
}

.dropzone:hover .ts-add-between {
    opacity: 1;
}

.ts-add-between:hover::before {
    color: var(--primary-color);
    border-color: var(--primary-color);
}


#card {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 400px;
    background-color: white;
    border: 1px solid var(--border-color);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    border-radius: 8px;
    z-index: 1000;
}

#card-title {
    padding: 12px 16px;
    background-color: var(--card-header-bg);
    color: var(--card-header-color);
    border-radius: 8px 8px 0 0;
    font-weight: 500;
    word-break: break-word;
}

#card-content {
    padding: 16px;
}

#card-description {
    width: 100%;
    min-height: 120px;
    padding: 10px;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    resize: vertical;
    font-family: inherit;
    line-height: 1.5;
    transition: border-color 0.2s ease;
}

#card-description:focus {
    outline: none;
    border-color: var(--focus-color);
    box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.25);
}

#card-nid,
#card-date {
    font-size: 0.8em;
    color: #888;
    padding: 5px 16px;
}

#card-close {
    margin: 10px 16px 16px;
    padding: 8px 12px;
    background-color: #f5f5f5;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    cursor: pointer;
    float: right;
    transition: background-color 0.2s;
}

#card-close:hover {
    background-color: #e0e0e0;
}

.hidden {
    display: none !important;
}


.ts-empty-state {
    padding: 1.5rem;
    text-align: center;
    border: 2px dashed #e0e0e0;
    border-radius: 8px;
    margin: 2rem 0;
}

.ts-empty-text {
    color: #888;
    cursor: pointer;
    padding: 1rem;
    font-size: 1.1rem;
    transition: color 0.2s;
}

.ts-empty-text:hover {
    color: var(--primary-color);
}


#shortcuts-text {
    position: fixed;
    top: 70px;
    left: 16px;
    padding: 12px 16px;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
    width: 220px;
    z-index: 20;
    line-height: 1.6;
}

#shortcuts-text h3 {
    margin-bottom: 8px;
    color: var(--primary-color);
}

#shortcuts-text ul {
    list-style-type: none;
    padding-left: 0;
}

#shortcuts-text li {
    margin-bottom: 6px;
}

#shortcuts-text strong {
    display: inline-block;
    min-width: 80px;
    color: #555;
}

================
File: src/domain/rdf/RDFModel.js
================
import rdf from 'rdf-ext'
import { RDFError } from '../../core/errors/error-types.js'
import { namespaces, generateNid } from '../../utils/utils.js'

class RDFModel {
    constructor() {
        this.ns = {}


        Object.entries(namespaces).forEach(([prefix, uri]) => {
            this.ns[prefix] = rdf.namespace(uri)
        })
    }






    createPostData(postData) {
        try {
            const dataset = rdf.dataset()



            const postId = postData.customId || generateNid(postData.content || '')
            const subject = rdf.namedNode(postId)

            // Get optional graph
            const graph = postData.graph ?
                rdf.namedNode(postData.graph) :
                null

            // Helper to add quads to dataset
            const addQuad = (s, p, o) => {
                if (graph) {
                    dataset.add(rdf.quad(s, p, o, graph))
                } else {
                    dataset.add(rdf.quad(s, p, o))
                }
            }

            // Add type based on postData.type, default to 'entry' if not specified
            const postType = postData.type || 'entry'
            addQuad(
                subject,
                this.ns.rdf('type'),
                this.ns.squirt(postType)
            )


            if (postData.content) {
                addQuad(
                    subject,
                    this.ns.squirt('content'),
                    rdf.literal(postData.content)
                )
            }


            addQuad(
                subject,
                this.ns.dc('created'),
                rdf.literal(new Date().toISOString(), rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
            )


            if (postData.title) {
                addQuad(
                    subject,
                    this.ns.dc('title'),
                    rdf.literal(postData.title)
                )
            }


            if (postData.tags && Array.isArray(postData.tags)) {
                postData.tags.forEach(tag => {
                    if (tag && typeof tag === 'string' && tag.trim().length > 0) {
                        addQuad(
                            subject,
                            this.ns.squirt('tag'),
                            rdf.literal(tag.trim())
                        )
                    }
                })
            }


            if (postType === 'link' && postData.url) {
                try {
                    const urlNode = rdf.namedNode(postData.url)
                    addQuad(
                        subject,
                        this.ns.squirt('url'),
                        urlNode
                    )
                } catch (urlError) {
                    console.warn(`Invalid URL provided for link post ${postId}: ${postData.url}`)

                    throw new RDFError(`Invalid URL format for link post: ${postData.url}`, { originalError: urlError, postData })
                }
            }


            if (postType === 'wiki') {
                addQuad(
                    subject,
                    this.ns.dc('modified'),
                    rdf.literal(new Date().toISOString(), rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
                )
            }


            if (postType === 'profile') {

                const foaf = this.ns.foaf || rdf.namespace('http://xmlns.com/foaf/0.1/')





                if (postData.foafName) {
                    addQuad(
                        subject,
                        foaf('name'),
                        rdf.literal(postData.foafName)
                    )
                }

                if (postData.foafNick) {
                    addQuad(
                        subject,
                        foaf('nick'),
                        rdf.literal(postData.foafNick)
                    )
                }

                if (postData.foafMbox) {
                    try {
                        const mboxNode = rdf.namedNode(postData.foafMbox)
                        addQuad(subject, foaf('mbox'), mboxNode)
                    } catch (mboxError) {
                        console.warn(`Invalid mbox URI provided for profile ${postId}: ${postData.foafMbox}`)
                        throw new RDFError(`Invalid mbox URI format for profile: ${postData.foafMbox}`, { originalError: mboxError, postData })
                    }
                }

                if (postData.foafHomepage) {
                    try {
                        const homepageNode = rdf.namedNode(postData.foafHomepage)
                        addQuad(subject, foaf('homepage'), homepageNode)
                    } catch (homepageError) {
                        console.warn(`Invalid homepage URL provided for profile ${postId}: ${postData.foafHomepage}`)
                        throw new RDFError(`Invalid homepage URL format for profile: ${postData.foafHomepage}`, { originalError: homepageError, postData })
                    }
                }

                if (postData.foafImg) {
                    try {
                        const imgNode = rdf.namedNode(postData.foafImg)
                        addQuad(subject, foaf('img'), imgNode)
                    } catch (imgError) {
                        console.warn(`Invalid image URL provided for profile ${postId}: ${postData.foafImg}`)
                        throw new RDFError(`Invalid image URL format for profile: ${postData.foafImg}`, { originalError: imgError, postData })
                    }
                }


                if (postData.foafAccounts && Array.isArray(postData.foafAccounts)) {
                    postData.foafAccounts.forEach(account => {

                        if (account && account.serviceHomepage) {
                            try {

                                const accountNode = rdf.blankNode()


                                addQuad(subject, foaf('account'), accountNode)


                                addQuad(
                                    accountNode,
                                    foaf('accountServiceHomepage'),
                                    rdf.namedNode(account.serviceHomepage)
                                )


                                if (account.accountName) {
                                    addQuad(
                                        accountNode,
                                        foaf('accountName'),
                                        rdf.literal(account.accountName)
                                    )
                                }
                            } catch (accountError) {
                                console.warn(`Invalid account data provided for profile ${postId}:`, account)

                            }
                        }
                    })
                }
            }


            for (const key in postData) {
                if (Object.hasOwnProperty.call(postData, key)) {

                    const knownProps = ['customId', 'graph', 'type', 'content', 'title', 'tags', 'url',
                        'foafName', 'foafNick', 'foafMbox', 'foafHomepage', 'foafImg', 'foafAccounts']
                    if (!knownProps.includes(key) && postData[key] !== undefined && postData[key] !== null) {

                        const value = postData[key]
                        let objectNode

                        if (typeof value === 'string' && (value.startsWith('http:') || value.startsWith('https:') || value.startsWith('urn:'))) {
                            try {
                                objectNode = rdf.namedNode(value)
                            } catch (uriError) {
                                console.warn(`Could not create named node for custom property ${key} with value ${value}. Treating as literal.`)
                                objectNode = rdf.literal(value.toString())
                            }
                        } else {

                            objectNode = rdf.literal(value.toString())
                        }
                        addQuad(subject, this.ns.squirt(key), objectNode)
                    }
                }
            }


            return {
                id: postId,
                dataset,
                subject: subject,
                graph: graph,
                originalData: postData
            }
        } catch (error) {

            if (error instanceof RDFError) {
                throw error
            }
            throw new RDFError(`Failed to create post data: ${error.message}`, {
                originalError: error,
                postData
            })
        }
    }
}
export default RDFModel

================
File: src/html/index.html
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trestle - Hierarchical Todo List</title>
    <link rel="stylesheet" href="css/trestle.css">
    <meta name="description" content="Trestle - A hierarchical todo list with SPARQL backend">
</head>

<body>
    <header id="header-outer">
        <div id="header">Trestle</div>

        <div class="top-navbar">
            <div class="toolbar">
                <ul>
                    <li><button id="saveButton">Save</button></li>
                    <li><button id="addButton">Add Root Item</button></li>
                    <li><button id="shortcutsButton">Shortcuts</button></li>
                </ul>
            </div>
        </div>

        <button class="hamburger-menu" aria-label="Menu" id="hamburgerButton">☰</button>
    </header>

    <div id="menu-box" class="hidden">
        <div class="toolbar">
            <ul>
                <li><button id="mobileaaveButton">Save</button></li>
                <li><button id="mobileAddButton">Add Root Item</button></li>
                <li><button id="mobileShortcutsButton">Shortcuts</button></li>
            </ul>
        </div>
    </div>

    <div id="shortcuts-text" class="text-box hidden">
        <h3>Keyboard Shortcuts</h3>
        <ul>
            <li><strong>Enter</strong> New item</li>
            <li><strong>Shift+Enter</strong> Line break</li>
            <li><strong>Tab</strong> Indent</li>
            <li><strong>Shift+Tab</strong> Outdent</li>
            <li><strong>Up/Down</strong> Navigate</li>
            <li><strong>Ctrl+↑/↓</strong> Move item</li>
            <li><strong>Alt+Click</strong> Edit details</li>
        </ul>
    </div>

    <div id="container">
        <div class="page">
            <div id="trestle">
                <div id="trestle-root" class="ts-root"></div>
            </div>
        </div>
    </div>

    <div id="card" class="hidden">
        <div id="card-title">Title</div>
        <div id="card-content">
            <textarea id="card-description" placeholder="Add description..."></textarea>
        </div>
        <div id="card-nid" class="date"></div>
        <div id="card-date" class="date"></div>
        <button id="card-close">Close</button>
    </div>

    <template id="entry-template">
        <div class="ts-entry">
            <button class="ts-expander" aria-label="Toggle expand"></button>
            <div class="ts-handle" aria-hidden="true">⋮</div>
            <div class="ts-title" contenteditable="true"></div>
            <div class="ts-actions">
                <button class="ts-card" aria-label="Show card" title="Show details">📝</button>
                <button class="ts-addChild" aria-label="Add child" title="Add child item">+</button>
                <button class="ts-delete" aria-label="Delete" title="Delete item">×</button>
            </div>
            <span class="date hidden"></span>
        </div>
    </template>

    <script type="module" src="js/main.js"></script>
</body>

</html>

================
File: src/js/controller/TrestleController.js
================
export class TrestleController {






    constructor(model, view, eventBus) {
        this.model = model
        this.view = view
        this.eventBus = eventBus


        this.setupEventHandlers()
    }




    initialize() {
        this.model.initialize()
    }




    setupEventHandlers() {

        this.eventBus.on('view:addChild', this.handleAddChild.bind(this))
        this.eventBus.on('view:addSibling', this.handleAddSibling.bind(this))
        this.eventBus.on('view:updateNode', this.handleUpdateNode.bind(this))
        this.eventBus.on('view:deleteNode', this.handleDeleteNode.bind(this))


        this.eventBus.on('view:moveNode', this.handleMoveNode.bind(this))
        this.eventBus.on('view:indentNode', this.handleIndentNode.bind(this))
        this.eventBus.on('view:outdentNode', this.handleOutdentNode.bind(this))


        this.eventBus.on('view:getNodeData', this.handleGetNodeData.bind(this))


        this.eventBus.on('view:insertNodeAt', this.handleInsertNodeAt.bind(this))
    }





    async saveData() {
        try {
            const success = await this.model.saveData()
            if (success) {
                this.showNotification('Data saved successfully')
            } else {
                this.showNotification('Failed to save data', 'error')
            }
            return success
        } catch (error) {
            console.error('Save error:', error)
            this.showNotification('Error saving data', 'error')
            return false
        }
    }






    showNotification(message, type = 'info') {


        if (type === 'error') {
            alert(`Error: ${message}`)
        } else {
            alert(message)
        }
    }




    addRootItem() {
        const rootNode = this.model.getRootNode()
        if (!rootNode) return


        const node = this.model.addNode(rootNode.id, '', rootNode.children.length)

        this.eventBus.emit('node:added', {
            node,
            parentId: 'trestle-root'
        })
    }






    updateNodeDescription(nodeId, description) {
        this.model.updateNodeDescription(nodeId, description)
    }





    handleAddChild(data) {
        const { parentId } = data
        const parent = this.model.getNode(parentId)
        if (!parent) return


        const childIndex = parent.children ? parent.children.length : 0
        const node = this.model.addNode(parentId, '', childIndex)

        this.eventBus.emit('node:added', {
            node,
            parentId
        })
    }





    handleAddSibling(data) {
        const { nodeId } = data
        const node = this.model.getNode(nodeId)
        if (!node) return


        const parentId = node.parent
        const parent = this.model.getNode(parentId)
        if (!parent) return


        const siblingIndex = parent.children.indexOf(nodeId)
        if (siblingIndex === -1) return


        const newNode = this.model.addNode(parentId, '', siblingIndex + 1)

        this.eventBus.emit('node:added', {
            node: newNode,
            parentId
        })
    }





    handleInsertNodeAt(data) {
        const { parentId, index } = data
        const parent = this.model.getNode(parentId)
        if (!parent) return


        const node = this.model.addNode(parentId, '', index)

        this.eventBus.emit('node:added', {
            node,
            parentId
        })
    }





    handleUpdateNode(data) {
        const { nodeId, properties } = data

        this.model.updateNode(nodeId, properties)

        this.eventBus.emit('node:updated', {
            nodeId,
            properties
        })
    }





    handleDeleteNode(data) {
        const { nodeId } = data

        this.model.deleteNode(nodeId)

        this.eventBus.emit('node:deleted', {
            nodeId
        })
    }





    handleMoveNode(data) {
        const { nodeId, newParentId, newIndex } = data

        this.model.moveNode(nodeId, newParentId, newIndex)


    }





    handleIndentNode(data) {
        const { nodeId } = data
        const node = this.model.getNode(nodeId)
        if (!node || !node.parent) return

        const parent = this.model.getNode(node.parent)
        if (!parent || !parent.children) return


        const index = parent.children.indexOf(nodeId)
        if (index <= 0) return


        const newParentId = parent.children[index - 1]
        const newParent = this.model.getNode(newParentId)
        if (!newParent) return


        this.model.moveNode(nodeId, newParentId, newParent.children ? newParent.children.length : 0)


        this.eventBus.emit('view:nodeIndented', {
            nodeId,
            newParentId
        })
    }





    handleOutdentNode(data) {
        const { nodeId } = data
        const node = this.model.getNode(nodeId)
        if (!node || !node.parent) return

        const parent = this.model.getNode(node.parent)
        if (!parent || !parent.parent) return

        const grandparentId = parent.parent
        const grandparent = this.model.getNode(grandparentId)
        if (!grandparent) return


        const parentIndex = grandparent.children.indexOf(parent.id)
        if (parentIndex === -1) return


        this.model.moveNode(nodeId, grandparentId, parentIndex + 1)


        this.eventBus.emit('view:nodeOutdented', {
            nodeId,
            newParentId: grandparentId
        })
    }





    handleGetNodeData(data) {
        const { nodeId, callback } = data

        const node = this.model.getNode(nodeId)
        if (node && callback) {
            callback(node)
        }
    }
}

================
File: src/js/model/TrestleModel.js
================
import { Config } from '../config.js'
import { generateID, generateDate } from '../utils/utils.js'

export class TrestleModel {






    constructor(endpoint, baseUri, eventBus) {
        this.endpoint = endpoint
        this.baseUri = baseUri
        this.eventBus = eventBus
        this.rootId = null
        this.nodes = new Map()


        this.eventBus.on('node:updated', this.handleNodeUpdate.bind(this))
        this.eventBus.on('node:moved', this.handleNodeMove.bind(this))
        this.eventBus.on('node:deleted', this.handleNodeDelete.bind(this))
    }




    async initialize() {
        try {
            await this.loadData()
            this.eventBus.emit('model:loaded', { nodes: Array.from(this.nodes.values()) })
        } catch (error) {
            console.error('Failed to initialize model:', error)
            this.createEmptyModel()
        }
    }




    createEmptyModel() {
        const rootId = this.generateNodeId('root')
        this.rootId = rootId


        this.nodes.set(rootId, {
            id: rootId,
            type: 'RootNode',
            children: []
        })

        this.eventBus.emit('model:created', {
            rootId: this.rootId,
            nodes: Array.from(this.nodes.values())
        })
    }






    generateNodeId(prefix = 'nid') {
        return `${prefix}-${generateID()}`
    }





    async loadData() {
        try {
            const fURL = `${this.endpoint}?query=${encodeURIComponent(this.buildLoadQuery())}`

            const response = await fetch(fURL, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json'
                }
            })

            if (!response.ok) {
                throw new Error(`SPARQL query failed: ${response.statusText}`)
            }

            const data = await response.json()

            this.processLoadedData(data)

            return true
        } catch (error) {
            console.error('Error loading data:', error)
            throw error
        }
    }





    buildLoadQuery() {
        return `
            PREFIX dc: <${Config.PREFIXES.dc}>
            PREFIX ts: <${Config.PREFIXES.ts}>

            SELECT ?node ?type ?title ?created ?index ?parent WHERE {
                ?node a ?type .
                OPTIONAL { ?node dc:title ?title } .
                OPTIONAL { ?node dc:created ?created } .
                OPTIONAL { ?node ts:index ?index } .
                OPTIONAL { ?node ts:parent ?parent } .
             #   FILTER(STRSTARTS(STR(?type), "${Config.PREFIXES.ts}"))
            }
        `
    }





    processLoadedData(data) {

        this.nodes.clear()
        this.rootId = null


        const nodesMap = new Map()


        for (const binding of data.results.bindings) {
            const nodeUri = binding.node.value
            const nodeId = this.extractLocalId(nodeUri)
            const type = this.extractLocalType(binding.type.value)


            let node = nodesMap.get(nodeId) || { id: nodeId, children: [] }
            node.type = type

            if (binding.title) {
                node.title = binding.title.value
            }

            if (binding.created) {
                node.created = binding.created.value
            }

            if (binding.index) {
                node.index = parseInt(binding.index.value, 10)
            }

            if (binding.parent) {
                node.parent = this.extractLocalId(binding.parent.value)
            }


            if (type === 'RootNode') {
                this.rootId = nodeId
            }

            nodesMap.set(nodeId, node)
        }


        for (const [id, node] of nodesMap.entries()) {
            if (node.parent) {
                const parentNode = nodesMap.get(node.parent)
                if (parentNode) {
                    if (!parentNode.children) {
                        parentNode.children = []
                    }
                    parentNode.children.push(id)
                }
            }
        }


        for (const node of nodesMap.values()) {
            if (node.children && node.children.length > 0) {
                node.children.sort((a, b) => {
                    const nodeA = nodesMap.get(a)
                    const nodeB = nodesMap.get(b)
                    return (nodeA.index || 0) - (nodeB.index || 0)
                })
            }
        }


        this.nodes = nodesMap
    }






    extractLocalId(uri) {
        const parts = uri.split('/')
        return parts[parts.length - 1]
    }






    extractLocalType(uri) {
        const parts = uri.split('/')
        return parts[parts.length - 1]
    }








    addNode(parentId, title, index) {
        const nodeId = this.generateNodeId()
        const now = generateDate()

        const newNode = {
            id: nodeId,
            type: 'Node',
            title: title || '',
            created: now,
            parent: parentId,
            index: index,
            children: []
        }

        // Add to model
        this.nodes.set(nodeId, newNode)

        // Update parent's children
        const parentNode = this.nodes.get(parentId)
        if (parentNode) {
            if (!parentNode.children) {
                parentNode.children = []
            }

            if (typeof index === 'number') {
                parentNode.children.splice(index, 0, nodeId)
                this.updateChildIndices(parentNode)
            } else {
                newNode.index = parentNode.children.length
                parentNode.children.push(nodeId)
            }
        }

        return newNode
    }





    updateChildIndices(parentNode) {
        if (parentNode.children) {
            parentNode.children.forEach((childId, index) => {
                const child = this.nodes.get(childId)
                if (child) {
                    child.index = index
                }
            })
        }
    }







    moveNode(nodeId, newParentId, newIndex) {
        const node = this.nodes.get(nodeId)
        if (!node) return

        const oldParentId = node.parent
        const oldParent = this.nodes.get(oldParentId)


        if (oldParent && oldParent.children) {
            const oldIndex = oldParent.children.indexOf(nodeId)
            if (oldIndex !== -1) {
                oldParent.children.splice(oldIndex, 1)
                this.updateChildIndices(oldParent)
            }
        }


        const newParent = this.nodes.get(newParentId)
        if (newParent) {
            if (!newParent.children) {
                newParent.children = []
            }

            if (typeof newIndex === 'number') {
                newParent.children.splice(newIndex, 0, nodeId)
            } else {
                newParent.children.push(nodeId)
                newIndex = newParent.children.length - 1
            }


            node.parent = newParentId
            node.index = newIndex


            this.updateChildIndices(newParent)
        }
    }





    deleteNode(nodeId) {
        const node = this.nodes.get(nodeId)
        if (!node) return


        if (node.children && node.children.length > 0) {
            const childrenToDelete = [...node.children]
            for (const childId of childrenToDelete) {
                this.deleteNode(childId)
            }
        }


        const parentId = node.parent
        if (parentId) {
            const parent = this.nodes.get(parentId)
            if (parent && parent.children) {
                const index = parent.children.indexOf(nodeId)
                if (index !== -1) {
                    parent.children.splice(index, 1)
                    this.updateChildIndices(parent)
                }
            }
        }


        this.nodes.delete(nodeId)
    }






    updateNode(nodeId, properties) {
        const node = this.nodes.get(nodeId)
        if (!node) return


        Object.assign(node, properties)
    }






    updateNodeDescription(nodeId, description) {
        const node = this.nodes.get(nodeId)
        if (!node) return

        node.description = description
    }






    getNode(nodeId) {
        return this.nodes.get(nodeId)
    }





    getAllNodes() {
        return Array.from(this.nodes.values())
    }





    getRootNode() {
        return this.nodes.get(this.rootId)
    }





    toTurtle() {
        let turtle = `@prefix dc: <${Config.PREFIXES.dc}> .\n`
        turtle += `@prefix ts: <${Config.PREFIXES.ts}> .\n\n`


        const rootNode = this.nodes.get(this.rootId)
        if (rootNode) {
            turtle += `<${this.baseUri}${rootNode.id}> a ts:RootNode .\n`
        }


        for (const [id, node] of this.nodes.entries()) {

            if (id === this.rootId) continue

            if (node.type === 'Node') {
                turtle += `<${this.baseUri}${node.id}> a ts:Node;\n`


                if (node.title) {
                    turtle += `   dc:title "${this.escapeTurtle(node.title)}" ;\n`
                }


                if (node.created) {
                    turtle += `   dc:created "${node.created}" ;\n`
                }


                turtle += `   ts:index "${node.index}" ;\n`


                if (node.parent) {
                    turtle += `   ts:parent <${this.baseUri}${node.parent}> .\n`
                } else {

                    turtle += `   ts:parent <${this.baseUri}${this.rootId}> .\n`
                }


                if (node.description) {
                    turtle += `<${this.baseUri}${node.id}> dc:description """${this.escapeTurtle(node.description)}""" .\n`
                }
            }
        }

        return turtle
    }






    escapeTurtle(text) {
        if (!text) return ''
        return text
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t')
    }





    async saveData() {
        try {
            const turtle = this.toTurtle()

            const response = await fetch(this.endpoint, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'text/turtle'
                },
                body: turtle
            })

            if (!response.ok) {
                throw new Error(`Failed to save data: ${response.statusText}`)
            }

            return true
        } catch (error) {
            console.error('Error saving data:', error)
            this.eventBus.emit('model:error', { message: 'Failed to save data', error })
            return false
        }
    }





    handleNodeUpdate(data) {
        const { nodeId, properties } = data
        this.updateNode(nodeId, properties)
    }





    handleNodeMove(data) {
        const { nodeId, newParentId, newIndex } = data
        this.moveNode(nodeId, newParentId, newIndex)
    }





    handleNodeDelete(data) {
        const { nodeId } = data
        this.deleteNode(nodeId)
    }
}

================
File: src/js/model/TrestleRDFModel.js
================
import { TrestleModel } from './TrestleModel.js'
import { Config } from '../config.js'
import rdf from 'rdf-ext'




class TrestleRDFModel extends TrestleModel {






    constructor(endpoint, baseUri, eventBus) {

        super(endpoint, baseUri, eventBus)


        this.rdfDataset = rdf.dataset()
    }




    async initialize() {
        try {

            await super.initialize()


            this.buildRDFDataset()
        } catch (error) {
            console.error('Error in RDF initialization:', error)
        }
    }




    createEmptyModel() {

        super.createEmptyModel()


        this.buildRDFDataset()
    }




    buildRDFDataset() {

        this.rdfDataset = rdf.dataset()


        for (const [nodeId, node] of this.nodes.entries()) {
            this.addNodeToRDF(node)
        }
    }





    addNodeToRDF(node) {
        if (!node) return


        const ns = {
            rdf: rdf.namespace(Config.PREFIXES.rdf || 'http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
            dc: rdf.namespace(Config.PREFIXES.dc),
            ts: rdf.namespace(Config.PREFIXES.ts),
            xsd: rdf.namespace(Config.PREFIXES.xsd || 'http://www.w3.org/2001/XMLSchema#')
        }
        const subject = rdf.namedNode(`${this.baseUri}${node.id}`)


        const add = (p, o) => {
            if (o !== undefined && o !== null) {
                this.rdfDataset.add(rdf.quad(subject, p, o))
            }
        }


        add(ns.rdf('type'), ns.ts(node.type))


        if (node.title !== undefined) {
            add(ns.dc('title'), rdf.literal(node.title))
        }


        if (node.created) {
            add(ns.dc('created'), rdf.literal(node.created, ns.xsd('dateTime')))
        } else {

            add(ns.dc('created'), rdf.literal(new Date().toISOString(), ns.xsd('dateTime')))
        }


        if (node.description !== undefined) {
            add(ns.ts('description'), rdf.literal(node.description))
        }


        if (node.parent !== undefined && node.parent !== null) {
            add(ns.ts('parent'), rdf.namedNode(`${this.baseUri}${node.parent}`))
        }


        if (node.index !== undefined) {
            add(ns.ts('index'), rdf.literal(node.index.toString()))
        }
    }








    addNode(parentId, title, index) {

        const newNode = super.addNode(parentId, title, index)


        this.addNodeToRDF(newNode)

        return newNode
    }






    updateNode(nodeId, properties) {

        super.updateNode(nodeId, properties)


        const node = this.getNode(nodeId)
        if (node) {

            const quadsToRemove = this.rdfDataset.match(rdf.namedNode(`${this.baseUri}${nodeId}`))
            for (const quad of quadsToRemove) {
                this.rdfDataset.delete(quad)
            }


            this.addNodeToRDF(node)
        }
    }






    updateNodeDescription(nodeId, description) {

        super.updateNodeDescription(nodeId, description)


        const node = this.getNode(nodeId)
        if (node) {

            const descQuads = this.rdfDataset.match(
                rdf.namedNode(`${this.baseUri}${nodeId}`),
                rdf.namespace(Config.PREFIXES.dc)('description')
            )

            for (const quad of descQuads) {
                this.rdfDataset.delete(quad)
            }


            if (description) {
                this.rdfDataset.add(rdf.quad(
                    rdf.namedNode(`${this.baseUri}${nodeId}`),
                    rdf.namespace(Config.PREFIXES.dc)('description'),
                    rdf.literal(description)
                ))
            }
        }
    }





    deleteNode(nodeId) {

        const allNodesToDelete = this.getAllDescendantIds(nodeId)
        allNodesToDelete.push(nodeId)


        super.deleteNode(nodeId)


        for (const idToDelete of allNodesToDelete) {
            this.removeNodeFromRDF(idToDelete)
        }
    }






    getAllDescendantIds(nodeId) {
        const node = this.getNode(nodeId)
        if (!node || !node.children || node.children.length === 0) {
            return []
        }

        let descendantIds = []
        for (const childId of node.children) {
            descendantIds.push(childId)
            descendantIds = descendantIds.concat(this.getAllDescendantIds(childId))
        }
        return descendantIds
    }





    removeNodeFromRDF(nodeId) {
        const subject = rdf.namedNode(`${this.baseUri}${nodeId}`)


        const quadsToRemove = []


        for (const quad of this.rdfDataset.match(subject)) {
            quadsToRemove.push(quad)
        }


        for (const quad of this.rdfDataset.match(null, null, subject)) {
            quadsToRemove.push(quad)
        }


        for (const quad of quadsToRemove) {
            this.rdfDataset.delete(quad)
        }
    }







    moveNode(nodeId, newParentId, newIndex) {

        super.moveNode(nodeId, newParentId, newIndex)


        const node = this.getNode(nodeId)
        if (node) {

            this.removeNodeFromRDF(nodeId)
            this.addNodeToRDF(node)
        }


        const newParent = this.getNode(newParentId)
        if (newParent && newParent.children) {
            for (const childId of newParent.children) {
                const child = this.getNode(childId)
                if (child) {
                    this.removeNodeFromRDF(childId)
                    this.addNodeToRDF(child)
                }
            }
        }
    }





    toTurtle() {

        return super.toTurtle()
    }





    getRDFDataset() {
        return this.rdfDataset
    }
}

export default TrestleRDFModel

================
File: src/js/utils/EventBus.js
================
export class EventBus {
    constructor() {
        this.subscribers = new Map()
    }







    subscribe(event, callback) {
        if (!this.subscribers.has(event)) {
            this.subscribers.set(event, [])
        }

        const callbacks = this.subscribers.get(event)
        callbacks.push(callback)


        return () => {
            const index = callbacks.indexOf(callback)
            if (index !== -1) {
                callbacks.splice(index, 1)
            }
        }
    }






    publish(event, data = {}) {
        if (!this.subscribers.has(event)) {
            return
        }

        const callbacks = this.subscribers.get(event)
        callbacks.forEach(callback => {
            try {
                callback(data)
            } catch (error) {
                console.error(`Error in event handler for ${event}:`, error)
            }
        })
    }





    unsubscribeAll(event) {
        if (event) {
            this.subscribers.delete(event)
        } else {
            this.subscribers.clear()
        }
    }
}

================
File: src/js/utils/utils.js
================
export function generateID() {
    const now = new Date()
    const timestamp = formatDate(now, "yyyy-mm-dd-HH-MM-ss-l")
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0')
    return `${timestamp}-${random}`
}





export function generateDate() {
    return new Date().toISOString()
}








export function formatDate(date, mask, utc = true) {
    const token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g
    const timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g
    const timezoneClip = /[^-+\dA-Z]/g

    const pad = (val, len) => {
        val = String(val)
        len = len || 2
        while (val.length < len) val = "0" + val
        return val
    }


    if (arguments.length === 1 && Object.prototype.toString.call(date) === "[object String]" && !/\d/.test(date)) {
        mask = date
        date = undefined
    }


    date = date ? new Date(date) : new Date()
    if (isNaN(date)) throw SyntaxError("invalid date")

    mask = String(masks[mask] || mask || masks["default"])


    if (mask.slice(0, 4) === "UTC:") {
        mask = mask.slice(4)
        utc = true
    }

    const _ = utc ? "getUTC" : "get"
    const d = date[_ + "Date"]()
    const D = date[_ + "Day"]()
    const m = date[_ + "Month"]()
    const y = date[_ + "FullYear"]()
    const H = date[_ + "Hours"]()
    const M = date[_ + "Minutes"]()
    const s = date[_ + "Seconds"]()
    const L = date[_ + "Milliseconds"]()
    const o = utc ? 0 : date.getTimezoneOffset()

    const flags = {
        d: d,
        dd: pad(d),
        ddd: dayNames[D],
        dddd: dayNames[D + 7],
        m: m + 1,
        mm: pad(m + 1),
        mmm: monthNames[m],
        mmmm: monthNames[m + 12],
        yy: String(y).slice(2),
        yyyy: y,
        h: H % 12 || 12,
        hh: pad(H % 12 || 12),
        H: H,
        HH: pad(H),
        M: M,
        MM: pad(M),
        s: s,
        ss: pad(s),
        l: pad(L, 3),
        L: pad(L > 99 ? Math.round(L / 10) : L),
        t: H < 12 ? "a" : "p",
        tt: H < 12 ? "am" : "pm",
        T: H < 12 ? "A" : "P",
        TT: H < 12 ? "AM" : "PM",
        Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
        o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
        S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
    }

    return mask.replace(token, function ($0) {
        return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1)
    })
}


const masks = {
    "default": "ddd mmm dd yyyy HH:MM:ss",
    shortDate: "m/d/yy",
    mediumDate: "mmm d, yyyy",
    longDate: "mmmm d, yyyy",
    fullDate: "dddd, mmmm d, yyyy",
    shortTime: "h:MM TT",
    mediumTime: "h:MM:ss TT",
    longTime: "h:MM:ss TT Z",
    isoDate: "yyyy-mm-dd",
    isoTime: "HH:MM:ss",
    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
}


const dayNames = [
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
]

const monthNames = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
]






export function escapeHtml(text) {
    if (!text) return ''

    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;')
}






export function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj
    }

    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item))
    }

    const cloned = {}
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            cloned[key] = deepClone(obj[key])
        }
    }

    return cloned
}

================
File: src/js/view/TrestleView.js
================
export class TrestleView {





    constructor(rootElement, eventBus) {
        this.rootElement = rootElement
        this.eventBus = eventBus
        this.template = document.getElementById('entry-template')
        this.nodeElements = new Map()
        this.selectedNodeId = null
        this.draggedNodeId = null
        this.dragTarget = null
        this.editingId = null


        this.eventBus.on('model:loaded', this.renderTree.bind(this))
        this.eventBus.on('model:created', this.renderTree.bind(this))
        this.eventBus.on('node:added', this.handleNodeAdded.bind(this))
        this.eventBus.on('node:updated', this.handleNodeUpdated.bind(this))
        this.eventBus.on('node:deleted', this.handleNodeDeleted.bind(this))
        this.eventBus.on('view:nodeIndented', this.handleNodeIndented.bind(this))
        this.eventBus.on('view:nodeOutdented', this.handleNodeOutdented.bind(this))


        document.addEventListener('keydown', this.handleGlobalKeyDown.bind(this))
    }





    renderTree(data) {

        this.rootElement.innerHTML = ''
        this.nodeElements.clear()

        const rootNode = data.nodes.find(node => node.type === 'RootNode')
        if (!rootNode) {
            console.error('No root node found')
            return
        }


        const tree = this.buildTreeStructure(data.nodes, rootNode.id)


        const rootUl = document.createElement('ul')
        rootUl.className = 'ts-root'
        this.rootElement.appendChild(rootUl)


        for (const childId of tree.children || []) {
            this.renderNode(childId, rootUl, tree.nodes)
        }


        this.setupEventListeners()


        this.initDragAndDrop()


        this.addContextualAddButtons()


        if (!(tree.children && tree.children.length)) {
            this.showEmptyState(rootUl)
        }
    }





    showEmptyState(rootUl) {
        const emptyLi = document.createElement('li')
        emptyLi.className = 'ts-empty-state'

        const emptyText = document.createElement('div')
        emptyText.className = 'ts-empty-text'
        emptyText.textContent = 'Click here to add your first item'
        emptyText.addEventListener('click', () => {
            this.eventBus.emit('view:addChild', { parentId: 'trestle-root' })
        })

        emptyLi.appendChild(emptyText)
        rootUl.appendChild(emptyLi)
    }







    buildTreeStructure(nodes, rootId) {
        const nodesMap = new Map()


        for (const node of nodes) {
            nodesMap.set(node.id, { ...node })
        }


        for (const node of nodesMap.values()) {
            if (node.children) {

                node.children = node.children.filter(childId => nodesMap.has(childId))
            } else {
                node.children = []
            }
        }

        return {
            rootId,
            nodes: nodesMap
        }
    }








    renderNode(nodeId, parentElement, nodesMap) {
        const node = nodesMap.get(nodeId)
        if (!node) return null


        const li = document.createElement('li')
        li.dataset.nodeId = nodeId


        const dropzone = document.createElement('div')
        dropzone.className = 'dropzone'
        li.appendChild(dropzone)


        const entry = this.template.content.cloneNode(true).querySelector('.ts-entry')
        entry.id = nodeId


        const titleElement = entry.querySelector('.ts-title')
        titleElement.textContent = node.title || ''

        // Set created date (hidden)
        const dateElement = entry.querySelector('.date')
        dateElement.textContent = node.created || ''

        // Append entry to list item
        li.appendChild(entry)

        // Add to nodeElements map
        this.nodeElements.set(nodeId, li)

        // Render children if any
        if (node.children && node.children.length > 0) {
            const ul = document.createElement('ul')
            li.appendChild(ul)
            li.classList.add('ts-open')

            for (const childId of node.children) {
                this.renderNode(childId, ul, nodesMap)
            }
        } else {
            li.classList.add('ts-closed')
        }


        parentElement.appendChild(li)

        return li
    }




    addContextualAddButtons() {
        const dropzones = this.rootElement.querySelectorAll('.dropzone')

        dropzones.forEach(dropzone => {
            const addButton = document.createElement('div')
            addButton.className = 'ts-add-between'
            addButton.title = 'Add item here'

            addButton.addEventListener('click', (event) => {
                event.stopPropagation()

                const listItem = dropzone.closest('li')
                if (!listItem) return

                const nodeId = listItem.dataset.nodeId
                const parentElement = listItem.parentElement
                const parentNode = parentElement.closest('li')
                const parentId = parentNode ? parentNode.dataset.nodeId : 'trestle-root'


                const siblings = Array.from(parentElement.children)
                const index = siblings.indexOf(listItem)

                this.eventBus.emit('view:insertNodeAt', {
                    parentId,
                    index: index
                })
            })

            dropzone.appendChild(addButton)
        })
    }




    setupEventListeners() {

        this.rootElement.addEventListener('click', this.handleClick.bind(this))
        this.rootElement.addEventListener('dblclick', this.handleDblClick.bind(this))


        this.rootElement.addEventListener('keydown', this.handleKeyDown.bind(this))


        this.rootElement.addEventListener('focus', this.handleFocus.bind(this), true)
        this.rootElement.addEventListener('blur', this.handleBlur.bind(this), true)


        document.addEventListener('click', (event) => {

            const shortcutsPanel = document.getElementById('shortcuts-text')
            if (shortcutsPanel && !shortcutsPanel.classList.contains('hidden')) {
                if (!shortcutsPanel.contains(event.target) &&
                    event.target.id !== 'shortcutsButton' &&
                    event.target.id !== 'mobileShortcutsButton') {
                    shortcutsPanel.classList.add('hidden')
                }
            }
        })
    }




    handleGlobalKeyDown(event) {

        if (event.ctrlKey && event.key === 's') {
            event.preventDefault()
            document.getElementById('saveButton').click()
        }


        if (event.key === 'Escape' && this.editingId) {
            const editingTitle = document.getElementById(this.editingId)?.querySelector('.ts-title')
            if (editingTitle && editingTitle.isContentEditable) {
                editingTitle.blur()
                this.selectNode(this.editingId)
                this.editingId = null
            }
        }
    }




    handleClick(event) {
        const target = event.target


        if (target.classList.contains('ts-expander')) {
            const li = target.closest('li')
            li.classList.toggle('ts-closed')
            li.classList.toggle('ts-open')
            event.stopPropagation()
            return
        }


        if (target.classList.contains('ts-card') || (event.altKey && target.classList.contains('ts-title'))) {
            this.showCard(target.closest('.ts-entry').id)
            event.stopPropagation()
            return
        }


        if (target.classList.contains('ts-addChild')) {
            const entryId = target.closest('.ts-entry').id
            this.eventBus.emit('view:addChild', { parentId: entryId })
            event.stopPropagation()
            return
        }


        if (target.classList.contains('ts-delete')) {
            const entryId = target.closest('.ts-entry').id
            if (confirm('Are you sure you want to delete this item and all its children?')) {
                this.eventBus.emit('view:deleteNode', { nodeId: entryId })
            }
            event.stopPropagation()
            return
        }


        if (target.classList.contains('ts-entry') || target.classList.contains('ts-title')) {
            const entry = target.classList.contains('ts-entry') ? target : target.closest('.ts-entry')
            this.selectNode(entry.id)
            event.stopPropagation()
            return
        }
    }




    handleDblClick(event) {
        const target = event.target


        if (target.classList.contains('ts-title')) {
            this.startEditing(target)
            event.stopPropagation()
        }
    }





    startEditing(titleElement) {
        titleElement.contentEditable = true
        titleElement.focus()
        this.editingId = titleElement.closest('.ts-entry').id


        const range = document.createRange()
        range.selectNodeContents(titleElement)
        const selection = window.getSelection()
        selection.removeAllRanges()
        selection.addRange(range)
    }




    handleKeyDown(event) {

        if (!event.target.isContentEditable) return

        const entry = event.target.closest('.ts-entry')
        if (!entry) return

        switch (event.key) {
            case 'Enter':
                if (event.shiftKey) {

                    return
                }


                event.preventDefault()
                event.target.contentEditable = false
                this.editingId = null


                const nodeId = entry.id
                const newTitle = event.target.textContent.trim()
                this.eventBus.emit('view:updateNode', { nodeId, properties: { title: newTitle } })

                const nodeLi = this.nodeElements.get(nodeId)
                if (nodeLi) {

                    const isFirstNode =
                        nodeLi.parentElement.classList.contains('ts-root') &&
                        !nodeLi.previousElementSibling

                    if (isFirstNode) {

                        this.eventBus.emit('view:addChild', { parentId: nodeId })
                    } else {

                        this.eventBus.emit('view:addSibling', { nodeId })
                    }
                }
                break

            case 'Tab':
                event.preventDefault()
                if (event.shiftKey) {

                    this.eventBus.emit('view:outdentNode', { nodeId: entry.id })
                } else {

                    this.eventBus.emit('view:indentNode', { nodeId: entry.id })
                }
                break

            case 'Escape':

                event.preventDefault()
                event.target.contentEditable = false
                this.editingId = null
                this.selectNode(entry.id)
                break

            case 'ArrowUp':
                if (event.ctrlKey) {

                    event.preventDefault()
                    this.moveNodeUp(entry.id)
                } else {

                    event.preventDefault()
                    this.navigateUp(entry.id)
                }
                break

            case 'ArrowDown':
                if (event.ctrlKey) {

                    event.preventDefault()
                    this.moveNodeDown(entry.id)
                } else {

                    event.preventDefault()
                    this.navigateDown(entry.id)
                }
                break
        }
    }





    moveNodeUp(nodeId) {
        const nodeLi = this.nodeElements.get(nodeId)
        if (!nodeLi) return

        const parent = nodeLi.parentElement
        const prevLi = nodeLi.previousElementSibling

        if (!prevLi) return

        const parentNode = parent.closest('li')
        const parentId = parentNode ? parentNode.dataset.nodeId : 'trestle-root'


        const children = Array.from(parent.children)
        const currentIndex = children.indexOf(nodeLi)
        const newIndex = currentIndex - 1

        this.eventBus.emit('view:moveNode', {
            nodeId,
            newParentId: parentId,
            newIndex
        })


        parent.insertBefore(nodeLi, prevLi)
    }





    moveNodeDown(nodeId) {
        const nodeLi = this.nodeElements.get(nodeId)
        if (!nodeLi) return

        const parent = nodeLi.parentElement
        const nextLi = nodeLi.nextElementSibling

        if (!nextLi) return

        const parentNode = parent.closest('li')
        const parentId = parentNode ? parentNode.dataset.nodeId : 'trestle-root'


        const children = Array.from(parent.children)
        const currentIndex = children.indexOf(nodeLi)
        const newIndex = currentIndex + 1

        this.eventBus.emit('view:moveNode', {
            nodeId,
            newParentId: parentId,
            newIndex
        })


        if (nextLi.nextElementSibling) {
            parent.insertBefore(nodeLi, nextLi.nextElementSibling)
        } else {
            parent.appendChild(nodeLi)
        }
    }




    handleFocus(event) {
        if (event.target.classList.contains('ts-title')) {
            const entry = event.target.closest('.ts-entry')
            this.selectNode(entry.id)
        }
    }




    handleBlur(event) {
        if (event.target.classList.contains('ts-title') && event.target.isContentEditable) {

            const entry = event.target.closest('.ts-entry')
            const nodeId = entry.id
            const newTitle = event.target.textContent.trim()

            this.eventBus.emit('view:updateNode', { nodeId, properties: { title: newTitle } })


            event.target.contentEditable = false
            this.editingId = null
        }
    }




    initDragAndDrop() {

        this.cleanupDragListeners()


        const handles = this.rootElement.querySelectorAll('.ts-handle')
        handles.forEach(handle => {

            handle._dragStartHandler = this.handleDragStart.bind(this)

            handle.setAttribute('draggable', 'true')
            handle.addEventListener('mousedown', handle._dragStartHandler)
            handle.addEventListener('dragstart', handle._dragStartHandler)
        })


        const entries = this.rootElement.querySelectorAll('.ts-entry')
        entries.forEach(entry => {
            entry.setAttribute('draggable', 'true')
        })


        const dropzones = this.rootElement.querySelectorAll('.dropzone')
        dropzones.forEach(dropzone => {

            dropzone._dragOverHandler = this.handleDragOver.bind(this)
            dropzone._dragLeaveHandler = this.handleDragLeave.bind(this)
            dropzone._dropHandler = this.handleDrop.bind(this)

            dropzone.addEventListener('dragover', dropzone._dragOverHandler)
            dropzone.addEventListener('dragleave', dropzone._dragLeaveHandler)
            dropzone.addEventListener('drop', dropzone._dropHandler)
        })


        const items = this.rootElement.querySelectorAll('li')
        items.forEach(item => {

            item._dragEnterHandler = this.handleDragEnter.bind(this)

            item.addEventListener('dragenter', item._dragEnterHandler)
        })
    }




    cleanupDragListeners() {

        const handles = this.rootElement.querySelectorAll('.ts-handle')
        handles.forEach(handle => {
            if (handle._dragStartHandler) {
                handle.removeEventListener('mousedown', handle._dragStartHandler)
                handle.removeEventListener('dragstart', handle._dragStartHandler)
                delete handle._dragStartHandler
            }
        })


        const dropzones = this.rootElement.querySelectorAll('.dropzone')
        dropzones.forEach(dropzone => {
            if (dropzone._dragOverHandler) {
                dropzone.removeEventListener('dragover', dropzone._dragOverHandler)
                delete dropzone._dragOverHandler
            }
            if (dropzone._dragLeaveHandler) {
                dropzone.removeEventListener('dragleave', dropzone._dragLeaveHandler)
                delete dropzone._dragLeaveHandler
            }
            if (dropzone._dropHandler) {
                dropzone.removeEventListener('drop', dropzone._dropHandler)
                delete dropzone._dropHandler
            }
        })


        const items = this.rootElement.querySelectorAll('li')
        items.forEach(item => {
            if (item._dragEnterHandler) {
                item.removeEventListener('dragenter', item._dragEnterHandler)
                delete item._dragEnterHandler
            }
        })
    }




    handleDragStart(event) {

        event.stopPropagation()


        const entry = event.target.closest('.ts-entry')
        if (!entry) {
            console.log('No entry found in drag start')
            return
        }


        this.draggedNodeId = entry.id
        console.log('Drag started for node:', this.draggedNodeId)


        if (event.dataTransfer) {

            event.dataTransfer.clearData()


            event.dataTransfer.setData('text/plain', entry.id)
            event.dataTransfer.setData('application/x-node-id', entry.id)
            event.dataTransfer.effectAllowed = 'move'


            try {
                const dragImage = entry.cloneNode(true)
                dragImage.style.width = `${entry.offsetWidth}px`
                dragImage.style.opacity = '0.7'
                dragImage.style.position = 'absolute'
                dragImage.style.top = '-1000px'
                document.body.appendChild(dragImage)
                event.dataTransfer.setDragImage(dragImage, 10, 10)


                setTimeout(() => {
                    document.body.removeChild(dragImage)
                }, 10)
            } catch (err) {
                console.warn('Error setting drag image:', err)

            }
        }


        entry.classList.add('ts-dragging')


        this.selectNode(entry.id)


        const listItem = entry.closest('li')
        if (listItem) {
            listItem.classList.add('ts-dragging-item')
        }


        document.body.classList.add('ts-dragging-active')


        const dragEndHandler = () => {
            this.handleDragEnd()
            document.removeEventListener('dragend', dragEndHandler)
        }

        document.addEventListener('dragend', dragEndHandler)
    }




    handleDragEnd() {
        console.log('Drag ended')


        document.querySelectorAll('.ts-dragging').forEach(el => {
            el.classList.remove('ts-dragging')
        })

        document.querySelectorAll('.ts-dragging-item').forEach(el => {
            el.classList.remove('ts-dragging-item')
        })

        document.querySelectorAll('.ts-highlight').forEach(el => {
            el.classList.remove('ts-highlight')
        })

        document.querySelectorAll('.dropzone.active').forEach(el => {
            el.classList.remove('active')
        })


        document.body.classList.remove('ts-dragging-active')


        this.draggedNodeId = null
        this.dragTarget = null
    }




    handleDragOver(event) {

        event.preventDefault()
        event.stopPropagation()

        if (!this.draggedNodeId) return


        let dropzone = event.target
        while (dropzone && !dropzone.classList.contains('dropzone')) {
            dropzone = dropzone.parentElement
        }

        if (!dropzone) return


        dropzone.classList.add('active')


        event.dataTransfer.effectAllowed = 'move'
        event.dataTransfer.dropEffect = 'move'
    }




    handleDragLeave(event) {

        let dropzone = event.target
        while (dropzone && !dropzone.classList.contains('dropzone')) {
            dropzone = dropzone.parentElement
        }

        if (!dropzone) return


        dropzone.classList.remove('active')
    }




    handleDragEnter(event) {
        const li = event.target.closest('li')
        if (!li || !this.draggedNodeId) return


        this.dragTarget = li


        li.classList.add('ts-highlight')


        if (this.dragEnterTimer) {
            clearTimeout(this.dragEnterTimer)
        }

        this.dragEnterTimer = setTimeout(() => {
            if (li.classList.contains('ts-closed')) {
                li.classList.remove('ts-closed')
                li.classList.add('ts-open')
            }
        }, 700)
    }




    handleDrop(event) {

        event.preventDefault()
        event.stopPropagation()


        let dropzone = event.target
        while (dropzone && !dropzone.classList.contains('dropzone')) {
            dropzone = dropzone.parentElement
        }

        if (!dropzone) return


        dropzone.classList.remove('active')


        if (!this.draggedNodeId) {
            console.log('No dragged node ID')
            return
        }

        const draggedLi = this.nodeElements.get(this.draggedNodeId)
        if (!draggedLi) {
            console.log('Dragged node element not found')
            return
        }


        const targetLi = dropzone.closest('li')
        if (!targetLi) {
            console.log('Target list item not found')
            return
        }


        const targetEntry = targetLi.querySelector('.ts-entry')
        if (!targetEntry) {
            console.log('Target entry not found')
            return
        }


        if (draggedLi.contains(targetLi)) {
            console.warn('Cannot drop onto a child element')
            return
        }


        const parentUl = targetLi.parentElement



        const dropzones = Array.from(targetLi.querySelectorAll('.dropzone'))
        const isDropAfter = dropzones.indexOf(dropzone) === 0

        console.log('Drop position:', isDropAfter ? 'before' : 'as child')

        let newParentId
        let newIndex

        if (isDropAfter) {

            const parentNode = parentUl.closest('li')
            newParentId = parentNode ? parentNode.dataset.nodeId : 'trestle-root'


            const siblings = Array.from(parentUl.children)
            newIndex = siblings.indexOf(targetLi)

            console.log('Drop as sibling - Parent:', newParentId, 'Index:', newIndex)
        } else {

            newParentId = targetLi.dataset.nodeId


            let childUl = targetLi.querySelector('ul')
            if (!childUl) {
                childUl = document.createElement('ul')
                targetLi.appendChild(childUl)
                targetLi.classList.remove('ts-closed')
                targetLi.classList.add('ts-open')
            }


            newIndex = childUl.children.length

            console.log('Drop as child - Parent:', newParentId, 'Index:', newIndex)
        }


        console.log('Moving node:', this.draggedNodeId, 'to parent:', newParentId, 'at index:', newIndex)
        this.eventBus.emit('view:moveNode', {
            nodeId: this.draggedNodeId,
            newParentId: newParentId,
            newIndex: newIndex
        })


        if (isDropAfter) {

            parentUl.insertBefore(draggedLi, targetLi)
        } else {

            const childUl = targetLi.querySelector('ul')
            childUl.appendChild(draggedLi)
        }


        this.draggedNodeId = null
        draggedLi.classList.remove('ts-dragging')


        document.querySelectorAll('.ts-highlight').forEach(el => {
            el.classList.remove('ts-highlight')
        })


        this.initDragAndDrop()


        this.addContextualAddButtons()
    }





    selectNode(nodeId) {

        if (this.selectedNodeId) {
            const prevSelected = document.getElementById(this.selectedNodeId)
            if (prevSelected) {
                prevSelected.classList.remove('ts-selected')
            }
        }


        this.selectedNodeId = nodeId
        const entry = document.getElementById(nodeId)
        if (entry) {
            entry.classList.add('ts-selected')


            entry.scrollIntoView({ behavior: 'smooth', block: 'nearest' })
        }
    }





    navigateUp(currentNodeId) {
        const currentLi = this.nodeElements.get(currentNodeId)
        if (!currentLi) return

        let prevLi = currentLi.previousElementSibling

        if (prevLi) {

            while (prevLi.classList.contains('ts-open') && prevLi.querySelector('ul')?.lastElementChild) {
                prevLi = prevLi.querySelector('ul').lastElementChild
            }


            const prevId = prevLi.querySelector('.ts-entry').id
            this.selectNode(prevId)
        } else {

            const parentLi = currentLi.parentElement.closest('li')
            if (parentLi) {
                const parentId = parentLi.querySelector('.ts-entry').id
                this.selectNode(parentId)
            }
        }
    }





    navigateDown(currentNodeId) {
        const currentLi = this.nodeElements.get(currentNodeId)
        if (!currentLi) return


        if (currentLi.classList.contains('ts-open')) {
            const firstChild = currentLi.querySelector('ul > li')
            if (firstChild) {
                const childId = firstChild.querySelector('.ts-entry').id
                this.selectNode(childId)
                return
            }
        }


        let nextLi = currentLi.nextElementSibling
        if (nextLi) {
            const nextId = nextLi.querySelector('.ts-entry').id
            this.selectNode(nextId)
            return
        }


        let parent = currentLi.parentElement.closest('li')
        while (parent) {
            const parentNext = parent.nextElementSibling
            if (parentNext) {
                const nextId = parentNext.querySelector('.ts-entry').id
                this.selectNode(nextId)
                return
            }
            parent = parent.parentElement.closest('li')
        }
    }





    showCard(nodeId) {
        const entry = document.getElementById(nodeId)
        if (!entry) return


        const title = entry.querySelector('.ts-title').textContent
        const date = entry.querySelector('.date').textContent


        this.eventBus.emit('view:getNodeData', {
            nodeId,
            callback: (node) => {
                const card = document.getElementById('card')
                const cardTitle = document.getElementById('card-title')
                const cardNid = document.getElementById('card-nid')
                const cardDate = document.getElementById('card-date')
                const cardDescription = document.getElementById('card-description')


                cardTitle.textContent = title
                cardNid.textContent = nodeId
                cardDate.textContent = date


                cardDescription.value = node.description || ''

                // Store node ID with the card
                card.dataset.nodeId = nodeId

                // Show the card
                card.classList.remove('hidden')


                cardDescription.focus()
            }
        })
    }





    handleNodeAdded(data) {
        const { node, parentId } = data


        let parentElement
        if (parentId === 'trestle-root') {
            parentElement = this.rootElement.querySelector('ul')


            const emptyState = parentElement.querySelector('.ts-empty-state')
            if (emptyState) {
                emptyState.remove()
            }
        } else {
            const parentLi = this.nodeElements.get(parentId)
            if (!parentLi) {
                console.error('Parent not found:', parentId)
                return
            }


            let ul = parentLi.querySelector('ul')
            if (!ul) {
                ul = document.createElement('ul')
                parentLi.appendChild(ul)
                parentLi.classList.remove('ts-closed')
                parentLi.classList.add('ts-open')
            }

            parentElement = ul
        }


        const nodesMap = new Map()
        nodesMap.set(node.id, node)


        const newNodeElement = this.renderNode(node.id, parentElement, nodesMap)


        if (newNodeElement) {
            const titleElement = newNodeElement.querySelector('.ts-title')
            this.selectNode(node.id)


            setTimeout(() => {
                this.startEditing(titleElement)
            }, 10)
        }


        this.initDragAndDrop()


        this.addContextualAddButtons()
    }





    handleNodeUpdated(data) {
        const { nodeId, properties } = data


        const nodeEntry = document.getElementById(nodeId)
        if (!nodeEntry) return


        if (properties.title !== undefined) {
            const titleElement = nodeEntry.querySelector('.ts-title')
            titleElement.textContent = properties.title
        }
    }





    handleNodeDeleted(data) {
        const { nodeId } = data


        const nodeLi = this.nodeElements.get(nodeId)
        if (nodeLi) {

            const parent = nodeLi.parentElement
            const isLastInList = parent.children.length === 1


            nodeLi.remove()
            this.nodeElements.delete(nodeId)


            if (isLastInList && parent.classList.contains('ts-root')) {
                this.showEmptyState(parent)
            }
        }
    }





    handleNodeIndented(data) {
        const { nodeId, newParentId } = data


        const nodeLi = this.nodeElements.get(nodeId)
        const newParentLi = this.nodeElements.get(newParentId)

        if (!nodeLi || !newParentLi) return


        let parentUl = newParentLi.querySelector('ul')
        if (!parentUl) {
            parentUl = document.createElement('ul')
            newParentLi.appendChild(parentUl)
            newParentLi.classList.remove('ts-closed')
            newParentLi.classList.add('ts-open')
        }


        parentUl.appendChild(nodeLi)


        this.initDragAndDrop()


        this.addContextualAddButtons()
    }





    handleNodeOutdented(data) {
        const { nodeId, newParentId } = data


        const nodeLi = this.nodeElements.get(nodeId)
        if (!nodeLi) return

        const oldParentLi = nodeLi.parentElement.closest('li')
        if (!oldParentLi) return


        let newParentList
        if (newParentId === 'trestle-root') {
            newParentList = this.rootElement.querySelector('ul')
        } else {
            const newParentLi = this.nodeElements.get(newParentId)
            if (!newParentLi) return


            newParentList = newParentLi.parentElement
        }

        if (!newParentList) return


        if (oldParentLi.nextElementSibling) {
            newParentList.insertBefore(nodeLi, oldParentLi.nextElementSibling)
        } else {
            newParentList.appendChild(nodeLi)
        }


        this.initDragAndDrop()


        this.addContextualAddButtons()
    }
}

================
File: src/js/config.js
================
export const Config = {


    SPARQL_ENDPOINT: 'https://fuseki.hyperdata.it/farelo',

    BASE_URI: 'http://hyperdata.it/trestle/',



    PREFIXES: {
        dc: 'http://purl.org/dc/terms/',
        ts: 'http://purl.org/stuff/trestle/'
    },


    AUTO_SAVE: false,
    AUTO_SAVE_INTERVAL: 60000,


    KEY_CODES: {
        TAB: 9,
        ENTER: 13,
        ESCAPE: 27,
        UP: 38,
        DOWN: 40
    }
}

================
File: src/js/main.js
================
import { TrestleModel } from './model/TrestleModel.js'
import TrestleRDFModel from './model/TrestleRDFModel.js'
import { TrestleView } from './view/TrestleView.js'
import { TrestleController } from './controller/TrestleController.js'
import { Config } from './config.js'
import { EventBus } from 'evb'

document.addEventListener('DOMContentLoaded', () => {

    const eventBus = new EventBus()


    const model = new TrestleRDFModel(Config.SPARQL_ENDPOINT, Config.BASE_URI, eventBus)
    const view = new TrestleView(document.getElementById('trestle-root'), eventBus)
    const controller = new TrestleController(model, view, eventBus)


    setupUIListeners(controller)


    controller.initialize()


    if (Config.AUTO_SAVE) {
        setupAutoSave(controller, Config.AUTO_SAVE_INTERVAL)
    }
})





function setupUIListeners(controller) {

    const saveButton = document.getElementById('saveButton')
    const mobileaaveButton = document.getElementById('mobileaaveButton')
    const addButton = document.getElementById('addButton')
    const mobileAddButton = document.getElementById('mobileAddButton')
    const shortcutsButton = document.getElementById('shortcutsButton')
    const mobileShortcutsButton = document.getElementById('mobileShortcutsButton')
    const cardClose = document.getElementById('card-close')
    const shortcutsText = document.getElementById('shortcuts-text')
    const hamburgerButton = document.getElementById('hamburgerButton')
    const menuBox = document.getElementById('menu-box')


    if (saveButton) {
        saveButton.addEventListener('click', () => controller.saveData())
    }

    if (mobileaaveButton) {
        mobileaaveButton.addEventListener('click', () => {
            controller.saveData()
            menuBox.classList.add('hidden')
        })
    }


    if (addButton) {
        addButton.addEventListener('click', () => controller.addRootItem())
    }

    if (mobileAddButton) {
        mobileAddButton.addEventListener('click', () => {
            controller.addRootItem()
            menuBox.classList.add('hidden')
        })
    }


    if (shortcutsButton) {
        shortcutsButton.addEventListener('click', () => {
            if (shortcutsText) {
                shortcutsText.classList.toggle('hidden')
            }
        })
    }

    if (mobileShortcutsButton) {
        mobileShortcutsButton.addEventListener('click', () => {
            if (shortcutsText) {
                shortcutsText.classList.toggle('hidden')
                menuBox.classList.add('hidden')
            }
        })
    }


    if (hamburgerButton && menuBox) {
        hamburgerButton.addEventListener('click', (event) => {
            menuBox.classList.toggle('hidden')
            event.stopPropagation()
        })
    }


    if (menuBox) {
        document.addEventListener('click', (event) => {
            if (!menuBox.classList.contains('hidden') &&
                !menuBox.contains(event.target) &&
                event.target !== hamburgerButton) {
                menuBox.classList.add('hidden')
            }
        })
    }


    if (cardClose) {
        cardClose.addEventListener('click', () => {
            const card = document.getElementById('card')
            const cardDescription = document.getElementById('card-description')


            if (card && card.dataset.nodeId) {
                controller.updateNodeDescription(card.dataset.nodeId, cardDescription.value)
            }


            card.classList.add('hidden')
        })
    }


    document.getElementById('trestle').addEventListener('click', (event) => {

        if (event.target.id === 'trestle' || event.target.id === 'trestle-root') {

            const rootElement = document.getElementById('trestle-root')
            if (!rootElement.querySelector('li:not(.ts-empty-state)')) {
                controller.addRootItem()
            }
        }
    })


    document.addEventListener('keydown', (event) => {

        if ((event.ctrlKey || event.metaKey) && event.key === 's') {
            event.preventDefault()
            controller.saveData()
        }


        if ((event.ctrlKey || event.metaKey) && event.key === 'n') {
            event.preventDefault()
            controller.addRootItem()
        }
    })
}






function setupAutoSave(controller, interval) {

    setInterval(() => {
        controller.saveData()
    }, interval)


    window.addEventListener('beforeunload', () => {
        controller.saveData()
    })
}

================
File: src/utils/utils.js
================
export const namespaces = {
    rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
    xsd: 'http://www.w3.org/2001/XMLSchema#',
    dc: 'http://purl.org/dc/terms/',
    foaf: 'http://xmlns.com/foaf/0.1/',
    squirt: 'http://purl.org/stuff/squirt#',
    ts: 'http://purl.org/stuff/trestle#'
}





export function generateID() {
    const now = new Date()
    const timestamp = formatDate(now, "yyyy-mm-dd-HH-MM-ss-l")
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0')
    return `${timestamp}-${random}`
}





export function generateDate() {
    return new Date().toISOString()
}






export function generateNid(content) {

    let hash = 0
    if (content.length === 0) return 'nid-' + generateID()

    for (let i = 0; i < content.length; i++) {
        const char = content.charCodeAt(i)
        hash = ((hash << 5) - hash) + char
        hash = hash & hash
    }


    hash = Math.abs(hash)

    return 'nid-' + hash.toString(16) + '-' + Date.now().toString(36)
}








export function formatDate(date, mask, utc = true) {
    const token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g
    const timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g
    const timezoneClip = /[^-+\dA-Z]/g

    const pad = (val, len) => {
        val = String(val)
        len = len || 2
        while (val.length < len) val = "0" + val
        return val
    }


    if (arguments.length === 1 && Object.prototype.toString.call(date) === "[object String]" && !/\d/.test(date)) {
        mask = date
        date = undefined
    }


    date = date ? new Date(date) : new Date()
    if (isNaN(date)) throw SyntaxError("invalid date")

    mask = String(masks[mask] || mask || masks["default"])


    if (mask.slice(0, 4) === "UTC:") {
        mask = mask.slice(4)
        utc = true
    }

    const _ = utc ? "getUTC" : "get"
    const d = date[_ + "Date"]()
    const D = date[_ + "Day"]()
    const m = date[_ + "Month"]()
    const y = date[_ + "FullYear"]()
    const H = date[_ + "Hours"]()
    const M = date[_ + "Minutes"]()
    const s = date[_ + "Seconds"]()
    const L = date[_ + "Milliseconds"]()
    const o = utc ? 0 : date.getTimezoneOffset()

    const flags = {
        d: d,
        dd: pad(d),
        ddd: dayNames[D],
        dddd: dayNames[D + 7],
        m: m + 1,
        mm: pad(m + 1),
        mmm: monthNames[m],
        mmmm: monthNames[m + 12],
        yy: String(y).slice(2),
        yyyy: y,
        h: H % 12 || 12,
        hh: pad(H % 12 || 12),
        H: H,
        HH: pad(H),
        M: M,
        MM: pad(M),
        s: s,
        ss: pad(s),
        l: pad(L, 3),
        L: pad(L > 99 ? Math.round(L / 10) : L),
        t: H < 12 ? "a" : "p",
        tt: H < 12 ? "am" : "pm",
        T: H < 12 ? "A" : "P",
        TT: H < 12 ? "AM" : "PM",
        Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
        o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
        S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
    }

    return mask.replace(token, function ($0) {
        return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1)
    })
}




const masks = {
    "default": "ddd mmm dd yyyy HH:MM:ss",
    shortDate: "m/d/yy",
    mediumDate: "mmm d, yyyy",
    longDate: "mmmm d, yyyy",
    fullDate: "dddd, mmmm d, yyyy",
    shortTime: "h:MM TT",
    mediumTime: "h:MM:ss TT",
    longTime: "h:MM:ss TT Z",
    isoDate: "yyyy-mm-dd",
    isoTime: "HH:MM:ss",
    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
}




const dayNames = [
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
]




const monthNames = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
]






export function escapeHtml(text) {
    if (!text) return ''

    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;')
}






export function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj
    }

    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item))
    }

    const cloned = {}
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            cloned[key] = deepClone(obj[key])
        }
    }

    return cloned
}

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: jasmine.json
================
{
    "spec_dir": "test",
    "spec_files": [
        "**/*[sS]pec.js"
    ],
    "helpers": [],
    "stopSpecOnExpectationFailure": true,
    "random": false
}

================
File: jsdoc.json
================
{
  "tags": {
    "allowUnknownTags": true,
    "dictionaries": ["jsdoc", "closure"]
  },
  "source": {
    "include": ["js", "README.md"],
    "exclude": ["node_modules"],
    "includePattern": ".+\\.js(doc|x)?$",
    "excludePattern": "(^|\\/|\\\\)_"
  },
  "plugins": [
    "plugins/markdown"
  ],
  "templates": {
    "cleverLinks": false,
    "monospaceLinks": false,
    "default": {
      "outputSourceFiles": true,
      "includeDate": false
    }
  },
  "opts": {
    "destination": "./docs/jsdoc",
    "encoding": "utf8",
    "recurse": true,
    "template": "node_modules/docdash"
  }
}

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "trestle",
  "version": "0.9.0",
  "description": "A hierarchical todo list with SPARQL backend",
  "type": "module",
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack serve --mode development",
    "test": "jasmine --config=jasmine.json",
    "docs": "jsdoc -c jsdoc.json",
    "rp": "repomix -c repomix.config.json ."
  },
  "keywords": [
    "todo",
    "rdf",
    "sparql",
    "outliner",
    "hierarchical"
  ],
  "author": "Danny Ayers",
  "license": "MIT",
  "dependencies": {
    "@rdfjs/data-model": "^2.0.1",
    "@rdfjs/namespace": "^2.0.0",
    "@rdfjs/parser-n3": "^2.0.1",
    "evb": "file:../evb",
    "loglevel": "^1.8.1",
    "marked": "^5.0.0",
    "rdf-ext": "^2.2.0"
  },
  "devDependencies": {
    "@babel/core": "^7.23.5",
    "@babel/preset-env": "^7.23.5",
    "babel-loader": "^9.1.3",
    "chai": "^4.5.0",
    "copy-webpack-plugin": "^13.0.0",
    "css-loader": "^6.8.1",
    "html-webpack-plugin": "^5.6.3",
    "jasmine": "^4.6.0",
    "jsdoc": "^4.0.2",
    "jsdom": "^26.1.0",
    "style-loader": "^3.3.3",
    "webpack": "^5.89.0",
    "webpack-cli": "^5.1.4",
    "webpack-dev-server": "^4.15.2"
  }
}

================
File: README.md
================
# Trestle - Modern Hierarchical Todo List

Trestle is a web-based hierarchical todo list application with RDF/SPARQL backend support. It allows you to create, organize, and manage nested tasks with rich text descriptions using markdown.

## Features

- **Hierarchical Structure**: Organize tasks in a tree-like structure with unlimited nesting
- **Drag and Drop**: Easily reorganize tasks by dragging and dropping
- **Keyboard Navigation**: Navigate and edit using keyboard shortcuts
- **Markdown Support**: Write rich task descriptions using markdown
- **SPARQL Backend**: Store your data in a standard RDF triplestore
- **Card View**: View and edit detailed information for each task
- **Responsive Design**: Works on both desktop and mobile devices

## Getting Started

### Prerequisites

- Node.js 16 or later
- A SPARQL endpoint (like Apache Jena Fuseki) for data storage

### Installation

1. Clone the repository:

   ```bash
   git clone https://github.com/yourusername/trestle.git
   cd trestle
   ```

2. Install dependencies:

   ```bash
   npm install
   ```

3. Configure the application:

   - Edit `js/config.js` to set your SPARQL endpoint URL and other preferences

4. Start the development server:

   ```bash
   npm run dev
   ```

5. Build for production:
   ```bash
   npm run build
   ```

## Usage

### Keyboard Shortcuts

- **Enter**: Create a new sibling item
- **Tab**: Indent (make a child of previous item)
- **Shift+Tab**: Outdent (move to parent level)
- **Up/Down**: Navigate through items
- **Click** on an item to select it
- **Double-click** on an item to edit it

### Card View

Click the card icon (📄) next to any item to open its detail card. Here you can add and edit markdown descriptions.

### Drag and Drop

- Drag items using the handle (●) to reposition them
- Drop between items to place as a sibling
- Hold over an item to make the dragged item a child

## Data Model

Trestle uses RDF to represent the data structure with the following predicates:

- `dc:title`: Item title
- `dc:created`: Creation timestamp
- `dc:description`: Markdown description
- `ts:index`: Position in parent's children list
- `ts:parent`: Reference to parent node

## Development

### Project Structure

- `js/model/`: Data model and SPARQL interaction
- `js/view/`: UI rendering and event handling
- `js/controller/`: Application logic
- `js/utils/`: Utility functions and helpers

### Running Tests

```bash
npm test
```

### Generating Documentation

```bash
npm run docs
```

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgments

- Original Trestle concept by Danny Ayers
- Inspired by [Workflowy](https://workflowy.com)

================
File: webpack.config.js
================
import path from 'path'
import { fileURLToPath } from 'url'
import CopyWebpackPlugin from 'copy-webpack-plugin'
import HtmlWebpackPlugin from 'html-webpack-plugin'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

export default {
    entry: './src/js/main.js',
    resolve: {
        extensions: ['.js', '.json'],
        alias: {
            '@': path.resolve(__dirname, 'src')
        }
    },
    output: {
        filename: '[name].bundle.js',
        path: path.resolve(__dirname, 'dist/public'),
        publicPath: '/',
        clean: true,
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: [
                            ['@babel/preset-env', {
                                targets: {
                                    browsers: ['last 2 versions', 'not dead']
                                }
                            }]
                        ]
                    }
                }
            },
            {
                test: /\.css$/,
                use: ['style-loader', 'css-loader']
            }
        ]
    },
    devServer: {
        static: {
            directory: path.resolve(__dirname, 'dist/public')
        },
        port: 9090,
        open: true,
        hot: true
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: path.resolve(__dirname, 'src/html/index.html'),
            filename: 'index.html',
            inject: 'body'
        }),
        new CopyWebpackPlugin({
            patterns: [
                {
                    from: path.resolve(__dirname, 'src/css'),
                    to: path.resolve(__dirname, 'dist/public/css'),
                    globOptions: {
                        ignore: ['**/.*'],
                    },
                }
            ]
        })
    ],
    mode: 'development',
    devtool: 'inline-source-map',
}
