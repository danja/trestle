This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-17T17:17:54.529Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

Additional Info:
----------------
User Provided Header:
-----------------------
Trestle Source Code

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
src/
  core/
    errors/
      error-types.js
  css/
    trestle.css
  domain/
    rdf/
      RDFModel.js
  html/
    index.html
  js/
    controller/
      TrestleController.js
    model/
      TrestleModel.js
      TrestleRDFModel.js
    utils/
      EventBus.js
      utils.js
    view/
      TrestleView.js
    workers/
      turtleSerializer.js
    config.js
    main.js
  utils/
    utils.js
test/
  unit/
    TrestleModel.spec.js
    TrestleRDFModel.spec.js
jasmine.json
jsdoc.json
package.json
README.md
webpack.config.js

================================================================
Files
================================================================

================
File: src/core/errors/error-types.js
================
export class RDFError extends Error {






    constructor(message, details = {}) {
        super(message)
        this.name = 'RDFError'
        this.details = details


        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, RDFError)
        }
    }
}




export class ModelError extends Error {




    constructor(message, details = {}) {
        super(message)
        this.name = 'ModelError'
        this.details = details


        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, ModelError)
        }
    }
}

================
File: src/css/trestle.css
================
:root {
    --primary-color: #444;
    --secondary-color: #666;
    --highlight-color: #eee;
    --background-color: #fff;
    --border-color: #ddd;
    --selected-bg: #ffa;
    --highlight-bg: #f5f5f5;
    --card-header-bg: #666;
    --card-header-color: #fff;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html {
    background-color: var(--highlight-color);
    font-size: 16px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

body {
    height: 100vh;
    display: flex;
    flex-direction: column;
}


#header-outer {
    background-color: var(--primary-color);
    color: #fff;
    padding: 0 16px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 100;
    border-radius: 0;
}

#header {
    font-size: 1.5rem;
    font-weight: bold;
}


.top-navbar {
    display: flex;
    align-items: center;
}

.top-navbar .toolbar ul {
    display: flex;
    list-style-type: none;
    margin: 0;
    padding: 0;
}

.top-navbar .toolbar li {
    margin: 0 5px;
}

.top-navbar .toolbar button {
    background-color: #f5f5f5;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 5px 10px;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.2s;
}

.top-navbar .toolbar button:hover {
    background-color: #e0e0e0;
}


.hamburger-menu {
    display: none;
    cursor: pointer;
    background: none;
    border: none;
    padding: 10px;
    color: white;
    font-size: 1.5rem;
}


#menu-box {
    position: fixed;
    top: 60px;
    right: 0;
    background-color: var(--secondary-color);
    border-radius: 0 0 0 10px;
    padding: 10px;
    box-shadow: 1px 1px 1px #222;
    z-index: 10;
    width: auto;
    left: auto;
}

#menu-box.hidden {
    display: none;
}

#menu-box .toolbar ul {
    list-style-type: none;
    margin: 0;
    padding: 0.2em 0;
    background-color: var(--secondary-color);
    color: #fff;
}

#menu-box .toolbar li {
    text-align: center;
    margin: 5px;
}

#menu-box .toolbar button {
    width: 130px;
    background-color: #f5f5f5;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 5px;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.2s;
}

#menu-box .toolbar button:hover {
    background-color: #e0e0e0;
}


#container {
    position: fixed;
    top: 60px;
    left: 0;
    right: 0;
    bottom: 0;
    overflow-y: auto;
    padding: 2em;
    background-color: var(--background-color);
    box-shadow: 1px 1px 4px #444;
    z-index: 1;
}

.page {
    margin: 15px auto;
    max-width: 800px;
}


@media (min-width: 768px) {
    #menu-box {
        display: none !important;
    }

    .top-navbar {
        display: flex;
    }

    .hamburger-menu {
        display: none;
    }
}

@media (max-width: 767px) {
    .top-navbar {
        display: none;
    }

    .hamburger-menu {
        display: block;
    }
}


#trestle {
    display: block;
    margin: 0;
    list-style: none;
    user-select: none;
}

#trestle ul {
    font-size: 1em;
    list-style: none;
    padding-left: 20px;
}

#trestle li {
    display: block;
    position: relative;
    margin: 2px 0;
}

.ts-entry {
    position: relative;
    display: flex;
    align-items: center;
    min-height: 32px;
    padding: 4px 0;
    background: var(--background-color);
    border-radius: 4px;
}

.ts-entry:hover {
    background-color: var(--highlight-bg);
}

.ts-title {
    cursor: text;
    outline: none;
    padding: 0 4px;
    line-height: 1.5;
    flex-grow: 1;
}

.ts-title:focus {
    background-color: rgba(255, 255, 255, 0.8);
    border-bottom: 1px solid #ccc;
}

.ts-handle {
    display: none;
    cursor: move;
    color: #888;
    padding: 0 10px;
    font-size: 16px;
}

.ts-entry:hover .ts-handle {
    display: block;
}

.ts-actions {
    display: none;
    padding: 0 4px;
}

.ts-entry:hover .ts-actions {
    display: flex;
}

.ts-actions button {
    background: none;
    border: none;
    cursor: pointer;
    margin: 0 2px;
    padding: 2px;
    font-size: 14px;
}

.ts-actions button:hover {
    background-color: rgba(0, 0, 0, 0.1);
    border-radius: 4px;
}

.ts-expander {
    cursor: pointer;
    width: 20px;
    height: 20px;
    background: none;
    border: none;
    position: relative;
    margin-right: 4px;
}

.ts-expander::before {
    content: "▼";
    font-size: 10px;
    color: #888;
}

.ts-closed>.ts-entry>.ts-expander::before {
    content: "▶";
}

.ts-closed>ul {
    display: none;
}

.ts-highlight {
    background-color: var(--highlight-bg);
}

.ts-selected {
    background-color: var(--selected-bg);
}

.ts-dragging {
    opacity: 0.5;
}

.dropzone {
    height: 8px;
    background-color: transparent;
    transition: background-color 0.2s;
}

.dropzone.active {
    background-color: #dfd;
    height: 10px;
}

#card {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 350px;
    background-color: white;
    border: 1px solid var(--border-color);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    z-index: 1000;
}

#card-title {
    padding: 10px;
    background-color: var(--card-header-bg);
    color: var(--card-header-color);
    border-radius: 8px 8px 0 0;
    font-weight: bold;
    word-break: break-all;
}

#card-content {
    padding: 10px;
}

#card-description {
    width: 100%;
    min-height: 100px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    resize: vertical;
}

#card-nid,
#card-date {
    font-size: 0.8em;
    color: #666;
    padding: 5px 10px;
}

#card-close {
    margin: 10px;
    padding: 5px 10px;
    background-color: #f5f5f5;
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: pointer;
    float: right;
}

.hidden {
    display: none !important;
}

#shortcuts-text {
    position: fixed;
    top: 80px;
    left: 10px;
    padding: 10px;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    width: 200px;
    z-index: 20;
}

.drag-placeholder {
    border: 1px dashed #aaa;
    background-color: #f9f9f9;
    height: 30px;
    margin: 4px 0;
    border-radius: 4px;
}

[contenteditable="true"]:focus {
    background-color: white;
    padding: 2px 4px;
    outline: 1px solid #ddd;
}

.text-box {
    background-color: white;
    border-radius: 10px;
    padding: 10px;
    box-shadow: 1px 1px 1px #444;
}

================
File: src/domain/rdf/RDFModel.js
================
import rdf from 'rdf-ext'
import { RDFError } from '../../core/errors/error-types.js'
import { namespaces, generateNid } from '../../utils/utils.js'

class RDFModel {
    constructor() {
        this.ns = {}


        Object.entries(namespaces).forEach(([prefix, uri]) => {
            this.ns[prefix] = rdf.namespace(uri)
        })
    }






    createPostData(postData) {
        try {
            const dataset = rdf.dataset()



            const postId = postData.customId || generateNid(postData.content || '')
            const subject = rdf.namedNode(postId)

            // Get optional graph
            const graph = postData.graph ?
                rdf.namedNode(postData.graph) :
                null

            // Helper to add quads to dataset
            const addQuad = (s, p, o) => {
                if (graph) {
                    dataset.add(rdf.quad(s, p, o, graph))
                } else {
                    dataset.add(rdf.quad(s, p, o))
                }
            }

            // Add type based on postData.type, default to 'entry' if not specified
            const postType = postData.type || 'entry'
            addQuad(
                subject,
                this.ns.rdf('type'),
                this.ns.squirt(postType)
            )


            if (postData.content) {
                addQuad(
                    subject,
                    this.ns.squirt('content'),
                    rdf.literal(postData.content)
                )
            }


            addQuad(
                subject,
                this.ns.dc('created'),
                rdf.literal(new Date().toISOString(), rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
            )


            if (postData.title) {
                addQuad(
                    subject,
                    this.ns.dc('title'),
                    rdf.literal(postData.title)
                )
            }


            if (postData.tags && Array.isArray(postData.tags)) {
                postData.tags.forEach(tag => {
                    if (tag && typeof tag === 'string' && tag.trim().length > 0) {
                        addQuad(
                            subject,
                            this.ns.squirt('tag'),
                            rdf.literal(tag.trim())
                        )
                    }
                })
            }


            if (postType === 'link' && postData.url) {
                try {
                    const urlNode = rdf.namedNode(postData.url)
                    addQuad(
                        subject,
                        this.ns.squirt('url'),
                        urlNode
                    )
                } catch (urlError) {
                    console.warn(`Invalid URL provided for link post ${postId}: ${postData.url}`)

                    throw new RDFError(`Invalid URL format for link post: ${postData.url}`, { originalError: urlError, postData })
                }
            }


            if (postType === 'wiki') {
                addQuad(
                    subject,
                    this.ns.dc('modified'),
                    rdf.literal(new Date().toISOString(), rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
                )
            }


            if (postType === 'profile') {

                const foaf = this.ns.foaf || rdf.namespace('http://xmlns.com/foaf/0.1/')





                if (postData.foafName) {
                    addQuad(
                        subject,
                        foaf('name'),
                        rdf.literal(postData.foafName)
                    )
                }

                if (postData.foafNick) {
                    addQuad(
                        subject,
                        foaf('nick'),
                        rdf.literal(postData.foafNick)
                    )
                }

                if (postData.foafMbox) {
                    try {
                        const mboxNode = rdf.namedNode(postData.foafMbox)
                        addQuad(subject, foaf('mbox'), mboxNode)
                    } catch (mboxError) {
                        console.warn(`Invalid mbox URI provided for profile ${postId}: ${postData.foafMbox}`)
                        throw new RDFError(`Invalid mbox URI format for profile: ${postData.foafMbox}`, { originalError: mboxError, postData })
                    }
                }

                if (postData.foafHomepage) {
                    try {
                        const homepageNode = rdf.namedNode(postData.foafHomepage)
                        addQuad(subject, foaf('homepage'), homepageNode)
                    } catch (homepageError) {
                        console.warn(`Invalid homepage URL provided for profile ${postId}: ${postData.foafHomepage}`)
                        throw new RDFError(`Invalid homepage URL format for profile: ${postData.foafHomepage}`, { originalError: homepageError, postData })
                    }
                }

                if (postData.foafImg) {
                    try {
                        const imgNode = rdf.namedNode(postData.foafImg)
                        addQuad(subject, foaf('img'), imgNode)
                    } catch (imgError) {
                        console.warn(`Invalid image URL provided for profile ${postId}: ${postData.foafImg}`)
                        throw new RDFError(`Invalid image URL format for profile: ${postData.foafImg}`, { originalError: imgError, postData })
                    }
                }


                if (postData.foafAccounts && Array.isArray(postData.foafAccounts)) {
                    postData.foafAccounts.forEach(account => {

                        if (account && account.serviceHomepage) {
                            try {

                                const accountNode = rdf.blankNode()


                                addQuad(subject, foaf('account'), accountNode)


                                addQuad(
                                    accountNode,
                                    foaf('accountServiceHomepage'),
                                    rdf.namedNode(account.serviceHomepage)
                                )


                                if (account.accountName) {
                                    addQuad(
                                        accountNode,
                                        foaf('accountName'),
                                        rdf.literal(account.accountName)
                                    )
                                }
                            } catch (accountError) {
                                console.warn(`Invalid account data provided for profile ${postId}:`, account)

                            }
                        }
                    })
                }
            }


            for (const key in postData) {
                if (Object.hasOwnProperty.call(postData, key)) {

                    const knownProps = ['customId', 'graph', 'type', 'content', 'title', 'tags', 'url',
                        'foafName', 'foafNick', 'foafMbox', 'foafHomepage', 'foafImg', 'foafAccounts']
                    if (!knownProps.includes(key) && postData[key] !== undefined && postData[key] !== null) {

                        const value = postData[key]
                        let objectNode

                        if (typeof value === 'string' && (value.startsWith('http:') || value.startsWith('https:') || value.startsWith('urn:'))) {
                            try {
                                objectNode = rdf.namedNode(value)
                            } catch (uriError) {
                                console.warn(`Could not create named node for custom property ${key} with value ${value}. Treating as literal.`)
                                objectNode = rdf.literal(value.toString())
                            }
                        } else {

                            objectNode = rdf.literal(value.toString())
                        }
                        addQuad(subject, this.ns.squirt(key), objectNode)
                    }
                }
            }


            return {
                id: postId,
                dataset,
                subject: subject,
                graph: graph,
                originalData: postData
            }
        } catch (error) {

            if (error instanceof RDFError) {
                throw error
            }
            throw new RDFError(`Failed to create post data: ${error.message}`, {
                originalError: error,
                postData
            })
        }
    }
}
export default RDFModel

================
File: src/html/index.html
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trestle - Hierarchical Todo List</title>
    <link rel="stylesheet" href="css/trestle.css">
    <meta name="description" content="Trestle - A hierarchical todo list with SPARQL backend">
</head>

<body>
    <header id="header-outer">
        <div id="header">Trestle</div>


        <div class="top-navbar">
            <div class="toolbar">
                <ul>
                    <li><button id="saveButton">Save</button></li>
                    <li><button id="addButton">Add Root Item</button></li>
                    <li><button id="shortcutsButton">Shortcuts</button></li>
                    <li><button id="debugButton">Debug</button></li>
                </ul>
            </div>
        </div>


        <button class="hamburger-menu" aria-label="Menu" id="hamburgerButton">☰</button>
    </header>


    <div id="menu-box" class="hidden">
        <div class="toolbar">
            <ul>
                <li><button id="saveButton">Save</button></li>
                <li><button id="addButton">Add Root Item</button></li>
                <li><button id="shortcutsButton">Shortcuts</button></li>
                <li><button id="debugButton">Debug</button></li>
            </ul>
        </div>
    </div>

    <div id="shortcuts-text" class="text-box hidden">
        <h3>Keyboard Shortcuts</h3>
        <ul>
            <li><strong>Enter</strong>: Insert new item</li>
            <li><strong>Tab</strong>: Indent</li>
            <li><strong>Shift+Tab</strong>: Outdent</li>
            <li><strong>Up/Down</strong>: Navigate</li>
            <li><strong>Click</strong> on item to select</li>
            <li><strong>Double-click</strong> to edit</li>
        </ul>
    </div>

    <div id="container">
        <div class="page">
            <div id="trestle">
                <div id="trestle-root" class="ts-root"></div>
            </div>
        </div>
    </div>


    <div id="debug-output" class="text-box hidden">
        <h3>RDF Model (Turtle)</h3>
        <textarea id="debug-output-area" rows="15" readonly style="width: 95%; font-family: monospace;"></textarea>
        <button id="debug-close">Close</button>
    </div>

    <div id="card" class="hidden">
        <div id="card-title">Title</div>
        <div id="card-content">
            <textarea id="card-description" placeholder="Add description..."></textarea>
        </div>
        <div id="card-nid" class="date"></div>
        <div id="card-date" class="date"></div>
        <button id="card-close">Close</button>
    </div>

    <template id="entry-template">
        <div class="ts-entry">
            <button class="ts-expander" aria-label="Toggle expand"></button>
            <div class="ts-handle" aria-hidden="true">⊤</div>
            <div class="ts-title" contenteditable="true"></div>
            <div class="ts-actions">
                <button class="ts-card" aria-label="Show card">📄</button>
                <button class="ts-addChild" aria-label="Add child">➕</button>
                <button class="ts-delete" aria-label="Delete">❌</button>
            </div>
            <span class="date hidden"></span>
        </div>
    </template>

    <script type="module" src="js/main.js"></script>
</body>

</html>

================
File: src/js/controller/TrestleController.js
================
export class TrestleController {





    constructor(model, view, eventBus) {
        this.model = model
        this.view = view
        this.eventBus = eventBus


        this.setupEventHandlers()
    }




    initialize() {
        this.model.initialize()
    }




    setupEventHandlers() {

        this.eventBus.subscribe('view:addChild', this.handleAddChild.bind(this))
        this.eventBus.subscribe('view:addSibling', this.handleAddSibling.bind(this))
        this.eventBus.subscribe('view:updateNode', this.handleUpdateNode.bind(this))
        this.eventBus.subscribe('view:deleteNode', this.handleDeleteNode.bind(this))
        this.eventBus.subscribe('view:moveNode', this.handleMoveNode.bind(this))
        this.eventBus.subscribe('view:indentNode', this.handleIndentNode.bind(this))
        this.eventBus.subscribe('view:outdentNode', this.handleOutdentNode.bind(this))
        this.eventBus.subscribe('view:getNodeData', this.handleGetNodeData.bind(this))
    }




    async saveData() {
        const success = await this.model.saveData()
        if (success) {
            alert('Data saved successfully')
        } else {
            alert('Failed to save data')
        }
    }




    addRootItem() {
        const rootNode = this.model.getRootNode()
        if (!rootNode) return


        const node = this.model.addNode(rootNode.id, '', rootNode.children.length)
        this.eventBus.publish('node:added', {
            node,
            parentId: 'trestle-root'
        })
    }






    updateNodeDescription(nodeId, description) {
        this.model.updateNodeDescription(nodeId, description)
    }







    handleAddChild(data) {
        const { parentId } = data
        const parent = this.model.getNode(parentId)
        if (!parent) return

        const childIndex = parent.children ? parent.children.length : 0
        const node = this.model.addNode(parentId, '', childIndex)

        this.eventBus.publish('node:added', {
            node,
            parentId
        })
    }





    handleAddSibling(data) {
        const { nodeId } = data
        const node = this.model.getNode(nodeId)
        if (!node) return


        const parentId = node.parent
        const parent = this.model.getNode(parentId)
        if (!parent) return


        const siblingIndex = parent.children.indexOf(nodeId)
        if (siblingIndex === -1) return



        const newNode = this.model.addNode(parentId, '', siblingIndex + 1)
        //    const newNode = this.model.addNode(parentId, 'New Item', siblingIndex + 1)
        this.eventBus.publish('node:added', {
            node: newNode,
            parentId
        })
    }





    handleUpdateNode(data) {
        const { nodeId, properties } = data

        this.model.updateNode(nodeId, properties)

        this.eventBus.publish('node:updated', {
            nodeId,
            properties
        })
    }





    handleDeleteNode(data) {
        const { nodeId } = data

        this.model.deleteNode(nodeId)

        this.eventBus.publish('node:deleted', {
            nodeId
        })
    }





    handleMoveNode(data) {
        const { nodeId, newParentId, newIndex } = data

        this.model.moveNode(nodeId, newParentId, newIndex)


    }





    handleIndentNode(data) {
        const { nodeId } = data
        const node = this.model.getNode(nodeId)
        if (!node || !node.parent) return

        const parent = this.model.getNode(node.parent)
        if (!parent || !parent.children) return


        const index = parent.children.indexOf(nodeId)
        if (index <= 0) return


        const newParentId = parent.children[index - 1]
        const newParent = this.model.getNode(newParentId)
        if (!newParent) return


        this.model.moveNode(nodeId, newParentId, newParent.children ? newParent.children.length : 0)


        this.eventBus.publish('view:nodeIndented', {
            nodeId,
            newParentId
        })
    }





    handleOutdentNode(data) {
        const { nodeId } = data
        const node = this.model.getNode(nodeId)
        if (!node || !node.parent) return

        const parent = this.model.getNode(node.parent)
        if (!parent || !parent.parent) return

        const grandparentId = parent.parent
        const grandparent = this.model.getNode(grandparentId)
        if (!grandparent) return


        const parentIndex = grandparent.children.indexOf(parent.id)
        if (parentIndex === -1) return


        this.model.moveNode(nodeId, grandparentId, parentIndex + 1)


        this.eventBus.publish('view:nodeOutdented', {
            nodeId,
            newParentId: grandparentId
        })
    }





    handleGetNodeData(data) {
        const { nodeId, callback } = data

        const node = this.model.getNode(nodeId)
        if (node && callback) {
            callback(node)
        }
    }
}

================
File: src/js/model/TrestleModel.js
================
import { Config } from '../config.js'
import { generateID, generateDate } from '../utils/utils.js'

export class TrestleModel {





    constructor(endpoint, baseUri, eventBus) {
        this.endpoint = endpoint
        this.baseUri = baseUri
        this.eventBus = eventBus
        this.rootId = null
        this.nodes = new Map()


        this.eventBus.subscribe('node:updated', this.handleNodeUpdate.bind(this))
        this.eventBus.subscribe('node:moved', this.handleNodeMove.bind(this))
        this.eventBus.subscribe('node:deleted', this.handleNodeDelete.bind(this))
    }




    async initialize() {
        try {
            await this.loadData()
            this.eventBus.publish('model:loaded', { nodes: Array.from(this.nodes.values()) })
        } catch (error) {
            console.error('Failed to initialize model:', error)

            this.createEmptyModel()
        }
    }




    createEmptyModel() {
        const rootId = this.generateNodeId('root')
        this.rootId = rootId


        this.nodes.set(rootId, {
            id: rootId,
            type: 'RootNode',
            children: []
        })

        this.eventBus.publish('model:created', {
            rootId: this.rootId,
            nodes: Array.from(this.nodes.values())
        })
    }






    generateNodeId(prefix = 'nid') {
        return `${prefix}-${generateID()}`
    }




    async loadData() {
        try {
            const fURL = `${this.endpoint}?query=${encodeURIComponent(this.buildLoadQuery())}`

            const response = await fetch(fURL, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json'
                }
            })

            if (!response.ok) {
                throw new Error(`SPARQL query failed: ${response.statusText}`)
            }

            const data = await response.json()

            this.processLoadedData(data)

            return true
        } catch (error) {
            console.error('Error loading data:', error)
            throw error
        }
    }




    buildLoadQuery() {
        return `
            PREFIX dc: <${Config.PREFIXES.dc}>
            PREFIX ts: <${Config.PREFIXES.ts}>

            SELECT ?node ?type ?title ?created ?index ?parent WHERE {
                ?node a ?type .
                OPTIONAL { ?node dc:title ?title } .
                OPTIONAL { ?node dc:created ?created } .
                OPTIONAL { ?node ts:index ?index } .
                OPTIONAL { ?node ts:parent ?parent } .
             #   FILTER(STRSTARTS(STR(?type), "${Config.PREFIXES.ts}"))
            }
        `
    }





    processLoadedData(data) {

        this.nodes.clear()
        this.rootId = null


        const nodesMap = new Map()


        for (const binding of data.results.bindings) {
            const nodeUri = binding.node.value
            const nodeId = this.extractLocalId(nodeUri)
            const type = this.extractLocalType(binding.type.value)


            let node = nodesMap.get(nodeId) || { id: nodeId, children: [] }
            node.type = type

            if (binding.title) {
                node.title = binding.title.value
            }

            if (binding.created) {
                node.created = binding.created.value
            }

            if (binding.index) {
                node.index = parseInt(binding.index.value, 10)
            }

            if (binding.parent) {
                node.parent = this.extractLocalId(binding.parent.value)
            }


            if (type === 'RootNode') {
                this.rootId = nodeId
            }

            nodesMap.set(nodeId, node)
        }


        for (const [id, node] of nodesMap.entries()) {
            if (node.parent) {
                const parentNode = nodesMap.get(node.parent)
                if (parentNode) {
                    if (!parentNode.children) {
                        parentNode.children = []
                    }
                    parentNode.children.push(id)
                }
            }
        }


        for (const node of nodesMap.values()) {
            if (node.children && node.children.length > 0) {
                node.children.sort((a, b) => {
                    const nodeA = nodesMap.get(a)
                    const nodeB = nodesMap.get(b)
                    return (nodeA.index || 0) - (nodeB.index || 0)
                })
            }
        }


        this.nodes = nodesMap
    }






    extractLocalId(uri) {
        const parts = uri.split('/')
        return parts[parts.length - 1]
    }






    extractLocalType(uri) {
        const parts = uri.split('/')
        return parts[parts.length - 1]
    }








    addNode(parentId, title, index) {
        const nodeId = this.generateNodeId()
        const now = generateDate()

        const newNode = {
            id: nodeId,
            type: 'Node',

            title: title || '',
            created: now,
            parent: parentId,
            index: index,
            children: []
        }

        // Add to model
        this.nodes.set(nodeId, newNode)

        // Update parent's children
        const parentNode = this.nodes.get(parentId)
        if (parentNode) {
            if (!parentNode.children) {
                parentNode.children = []
            }

            if (typeof index === 'number') {
                parentNode.children.splice(index, 0, nodeId)


                this.updateChildIndices(parentNode)
            } else {

                newNode.index = parentNode.children.length
                parentNode.children.push(nodeId)
            }
        }

        return newNode
    }





    updateChildIndices(parentNode) {
        if (parentNode.children) {
            parentNode.children.forEach((childId, index) => {
                const child = this.nodes.get(childId)
                if (child) {
                    child.index = index
                }
            })
        }
    }







    moveNode(nodeId, newParentId, newIndex) {
        const node = this.nodes.get(nodeId)
        if (!node) return

        const oldParentId = node.parent
        const oldParent = this.nodes.get(oldParentId)


        if (oldParent && oldParent.children) {
            const oldIndex = oldParent.children.indexOf(nodeId)
            if (oldIndex !== -1) {
                oldParent.children.splice(oldIndex, 1)
                this.updateChildIndices(oldParent)
            }
        }


        const newParent = this.nodes.get(newParentId)
        if (newParent) {
            if (!newParent.children) {
                newParent.children = []
            }

            if (typeof newIndex === 'number') {
                newParent.children.splice(newIndex, 0, nodeId)
            } else {
                newParent.children.push(nodeId)
                newIndex = newParent.children.length - 1
            }


            node.parent = newParentId
            node.index = newIndex


            this.updateChildIndices(newParent)
        }
    }





    deleteNode(nodeId) {
        const node = this.nodes.get(nodeId)
        if (!node) return


        if (node.children && node.children.length > 0) {

            const childrenToDelete = [...node.children]
            for (const childId of childrenToDelete) {
                this.deleteNode(childId)
            }
        }


        const parentId = node.parent
        if (parentId) {
            const parent = this.nodes.get(parentId)
            if (parent && parent.children) {
                const index = parent.children.indexOf(nodeId)
                if (index !== -1) {
                    parent.children.splice(index, 1)
                    this.updateChildIndices(parent)
                }
            }
        }


        this.nodes.delete(nodeId)
    }






    updateNode(nodeId, properties) {
        const node = this.nodes.get(nodeId)
        if (!node) return


        Object.assign(node, properties)
    }






    updateNodeDescription(nodeId, description) {
        const node = this.nodes.get(nodeId)
        if (!node) return

        node.description = description
    }






    getNode(nodeId) {
        return this.nodes.get(nodeId)
    }





    getAllNodes() {
        return Array.from(this.nodes.values())
    }





    getRootNode() {
        return this.nodes.get(this.rootId)
    }





    toTurtle() {
        let turtle = `@prefix dc: <${Config.PREFIXES.dc}> .\n`
        turtle += `@prefix ts: <${Config.PREFIXES.ts}> .\n\n`


        const rootNode = this.nodes.get(this.rootId)
        if (rootNode) {
            turtle += `<${this.baseUri}${rootNode.id}> a ts:RootNode .\n`
        }


        for (const [id, node] of this.nodes.entries()) {

            if (id === this.rootId) continue

            if (node.type === 'Node') {
                turtle += `<${this.baseUri}${node.id}> a ts:Node;\n`


                if (node.title) {
                    turtle += `   dc:title "${this.escapeTurtle(node.title)}" ;\n`
                }


                if (node.created) {
                    turtle += `   dc:created "${node.created}" ;\n`
                }


                turtle += `   ts:index "${node.index}" ;\n`


                if (node.parent) {
                    turtle += `   ts:parent <${this.baseUri}${node.parent}> .\n`
                } else {

                    turtle += `   ts:parent <${this.baseUri}${this.rootId}> .\n`
                }


                if (node.description) {
                    turtle += `<${this.baseUri}${node.id}> dc:description """${this.escapeTurtle(node.description)}""" .\n`
                }
            }
        }

        return turtle
    }






    escapeTurtle(text) {
        if (!text) return ''
        return text
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t')
    }





    async saveData() {
        try {
            const turtle = this.toTurtle()

            const response = await fetch(this.endpoint, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'text/turtle'
                },
                body: turtle
            })

            if (!response.ok) {
                throw new Error(`Failed to save data: ${response.statusText}`)
            }

            return true
        } catch (error) {
            console.error('Error saving data:', error)
            this.eventBus.publish('model:error', { message: 'Failed to save data', error })
            return false
        }
    }







    handleNodeUpdate(data) {
        const { nodeId, properties } = data
        this.updateNode(nodeId, properties)
    }





    handleNodeMove(data) {
        const { nodeId, newParentId, newIndex } = data
        this.moveNode(nodeId, newParentId, newIndex)
    }





    handleNodeDelete(data) {
        const { nodeId } = data
        this.deleteNode(nodeId)
    }
}

================
File: src/js/model/TrestleRDFModel.js
================
import { TrestleModel } from "./TrestleModel.js"
import { Config } from "../config.js"
import rdf from "rdf-ext"
import TurtleSerializer from "@rdfjs/serializer-turtle"
import streamToString from "stream-to-string"

class TrestleRDFModel extends TrestleModel {
    constructor(endpoint, baseUri, eventBus) {
        super(endpoint, baseUri, eventBus)

        this.rdfDataset = rdf.dataset()
    }

    async initialize() {
        try {
            await super.initialize()

            this.buildRDFDataset()
        } catch (error) {
            console.error("Error in RDF initialization:", error)
        }
    }

    createEmptyModel() {
        super.createEmptyModel()

        this.buildRDFDataset()
    }

    buildRDFDataset() {
        this.rdfDataset = rdf.dataset()

        for (const [nodeId, node] of this.nodes.entries()) {
            this.addNodeToRDF(node)
        }
    }

    addNodeToRDF(node) {
        if (!node) return

        const ns = {
            rdf: rdf.namespace(
                Config.PREFIXES.rdf || "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
            ),
            dc: rdf.namespace(Config.PREFIXES.dc),
            ts: rdf.namespace(Config.PREFIXES.ts),
            xsd: rdf.namespace(
                Config.PREFIXES.xsd || "http://www.w3.org/2001/XMLSchema#"
            ),
        }
        const subject = rdf.namedNode(`${this.baseUri}${node.id}`)

        const add = (p, o) => {
            if (o !== undefined && o !== null) {
                this.rdfDataset.add(rdf.quad(subject, p, o))
            }
        }

        add(ns.rdf("type"), ns.ts(node.type))

        if (node.title !== undefined) {
            add(ns.dc("title"), rdf.literal(node.title))
        }

        if (node.created) {
            add(ns.dc("created"), rdf.literal(node.created, ns.xsd("dateTime")))
        } else {
            add(
                ns.dc("created"),
                rdf.literal(new Date().toISOString(), ns.xsd("dateTime"))
            )
        }

        if (node.description !== undefined) {
            add(ns.ts("description"), rdf.literal(node.description))
        }

        if (node.parent !== undefined && node.parent !== null) {
            add(ns.ts("parent"), rdf.namedNode(`${this.baseUri}${node.parent}`))
        }

        if (node.index !== undefined) {
            add(ns.ts("index"), rdf.literal(node.index.toString()))
        }
    }

    addNode(parentId, title, index) {
        const newNode = super.addNode(parentId, title, index)

        this.addNodeToRDF(newNode)

        return newNode
    }

    updateNode(nodeId, properties) {
        super.updateNode(nodeId, properties)

        const node = this.getNode(nodeId)
        if (node) {
            const quadsToRemove = this.rdfDataset.match(
                rdf.namedNode(`${this.baseUri}${nodeId}`)
            )
            for (const quad of quadsToRemove) {
                this.rdfDataset.delete(quad)
            }

            this.addNodeToRDF(node)
        }
    }

    updateNodeDescription(nodeId, description) {
        super.updateNodeDescription(nodeId, description)

        const node = this.getNode(nodeId)
        if (node) {
            const descQuads = this.rdfDataset.match(
                rdf.namedNode(`${this.baseUri}${nodeId}`),
                rdf.namespace(Config.PREFIXES.dc)("description")
            )
            for (const quad of descQuads) {
                this.rdfDataset.delete(quad)
            }

            if (description) {
                this.rdfDataset.add(
                    rdf.quad(
                        rdf.namedNode(`${this.baseUri}${nodeId}`),
                        rdf.namespace(Config.PREFIXES.dc)("description"),
                        rdf.literal(description)
                    )
                )
            }
        }
    }

    deleteNode(nodeId) {
        const allNodesToDelete = this.getAllDescendantIds(nodeId)
        allNodesToDelete.push(nodeId)

        super.deleteNode(nodeId)

        for (const idToDelete of allNodesToDelete) {
            this.removeNodeFromRDF(idToDelete)
        }
    }

    getAllDescendantIds(nodeId) {
        const node = this.getNode(nodeId)
        if (!node || !node.children || node.children.length === 0) {
            return []
        }

        let descendantIds = []
        for (const childId of node.children) {
            descendantIds.push(childId)

            descendantIds = descendantIds.concat(this.getAllDescendantIds(childId))
        }
        return descendantIds
    }

    removeNodeFromRDF(nodeId) {
        const subject = rdf.namedNode(`${this.baseUri}${nodeId}`)

        const quadsToRemove = []

        for (const quad of this.rdfDataset.match(subject)) {
            quadsToRemove.push(quad)
        }

        for (const quad of this.rdfDataset.match(null, null, subject)) {
            quadsToRemove.push(quad)
        }

        for (const quad of quadsToRemove) {
            this.rdfDataset.delete(quad)
        }
    }

    moveNode(nodeId, newParentId, newIndex) {
        super.moveNode(nodeId, newParentId, newIndex)

        const node = this.getNode(nodeId)
        if (node) {
            this.removeNodeFromRDF(nodeId)
            this.addNodeToRDF(node)
        }

        const newParent = this.getNode(newParentId)
        if (newParent && newParent.children) {
            for (const childId of newParent.children) {
                const child = this.getNode(childId)
                if (child) {
                    this.removeNodeFromRDF(childId)
                    this.addNodeToRDF(child)
                }
            }
        }
    }

    toTurtle() {
        return new Promise((resolve, reject) => {
            if (!window.Worker) {

                try {
                    const serializer = new TurtleSerializer()
                    const input = this.rdfDataset.toStream()
                    const output = serializer.import(input)

                    let turtleString = ""
                    output.on("data", (chunk) => {
                        turtleString += chunk.toString()
                    })

                    output.on("end", () => {
                        resolve(turtleString)
                    })

                    output.on("error", (err) => {
                        reject(new Error(`Serialization error: ${err.message}`))
                    })
                } catch (error) {
                    reject(new Error(`Serialization setup failed: ${error.message}`))
                }
                return
            }


            let worker
            try {
                worker = new Worker(
                    new URL("../workers/turtleSerializer.js", import.meta.url),
                    { type: "module" }
                )
            } catch (error) {
                reject(new Error(`Failed to create worker: ${error.message}`))
                return
            }


            const timeoutId = setTimeout(() => {
                if (worker) {
                    worker.terminate()
                    reject(new Error("Serialization timeout after 10 seconds"))
                }
            }, 10000)


            worker.onmessage = (event) => {
                if (event.data.ready) {
                    console.log("Turtle Serializer Worker ready.")
                    try {
                        const nquadsData = this.rdfDataset.toString()
                        worker.postMessage(nquadsData)
                    } catch (error) {
                        clearTimeout(timeoutId)
                        reject(new Error(`Error sending data to worker: ${error.message}`))
                        worker.terminate()
                    }
                    return
                }

                clearTimeout(timeoutId)

                if (event.data.error) {
                    console.error("Worker reported an error:", event.data.error)
                    reject(new Error(event.data.error))
                    worker.terminate()
                } else if (event.data.turtle) {
                    resolve(event.data.turtle)
                    worker.terminate()
                }
            }

            worker.onerror = (error) => {
                clearTimeout(timeoutId)
                console.error("Worker error:", error)
                reject(new Error(`Worker error: ${error.message}`))
                worker.terminate()
            }
        })
    }

    getRDFDataset() {
        return this.rdfDataset
    }
}
export default TrestleRDFModel

================
File: src/js/utils/EventBus.js
================
export class EventBus {
    constructor() {
        this.subscribers = new Map();
    }







    subscribe(event, callback) {
        if (!this.subscribers.has(event)) {
            this.subscribers.set(event, []);
        }

        const callbacks = this.subscribers.get(event);
        callbacks.push(callback);


        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1) {
                callbacks.splice(index, 1);
            }
        };
    }






    publish(event, data = {}) {
        if (!this.subscribers.has(event)) {
            return;
        }

        const callbacks = this.subscribers.get(event);
        callbacks.forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error(`Error in event handler for ${event}:`, error);
            }
        });
    }





    unsubscribeAll(event) {
        if (event) {
            this.subscribers.delete(event);
        } else {
            this.subscribers.clear();
        }
    }
}

================
File: src/js/utils/utils.js
================
export function generateID() {
    const now = new Date()
    const timestamp = formatDate(now, "yyyy-mm-dd-HH-MM-ss-l")
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0')
    return `${timestamp}-${random}`
}





export function generateDate() {
    return new Date().toISOString()
}








export function formatDate(date, mask, utc = true) {
    const token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g
    const timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g
    const timezoneClip = /[^-+\dA-Z]/g

    const pad = (val, len) => {
        val = String(val)
        len = len || 2
        while (val.length < len) val = "0" + val
        return val
    }


    if (arguments.length === 1 && Object.prototype.toString.call(date) === "[object String]" && !/\d/.test(date)) {
        mask = date
        date = undefined
    }


    date = date ? new Date(date) : new Date()
    if (isNaN(date)) throw SyntaxError("invalid date")

    mask = String(masks[mask] || mask || masks["default"])


    if (mask.slice(0, 4) === "UTC:") {
        mask = mask.slice(4)
        utc = true
    }

    const _ = utc ? "getUTC" : "get"
    const d = date[_ + "Date"]()
    const D = date[_ + "Day"]()
    const m = date[_ + "Month"]()
    const y = date[_ + "FullYear"]()
    const H = date[_ + "Hours"]()
    const M = date[_ + "Minutes"]()
    const s = date[_ + "Seconds"]()
    const L = date[_ + "Milliseconds"]()
    const o = utc ? 0 : date.getTimezoneOffset()

    const flags = {
        d: d,
        dd: pad(d),
        ddd: dayNames[D],
        dddd: dayNames[D + 7],
        m: m + 1,
        mm: pad(m + 1),
        mmm: monthNames[m],
        mmmm: monthNames[m + 12],
        yy: String(y).slice(2),
        yyyy: y,
        h: H % 12 || 12,
        hh: pad(H % 12 || 12),
        H: H,
        HH: pad(H),
        M: M,
        MM: pad(M),
        s: s,
        ss: pad(s),
        l: pad(L, 3),
        L: pad(L > 99 ? Math.round(L / 10) : L),
        t: H < 12 ? "a" : "p",
        tt: H < 12 ? "am" : "pm",
        T: H < 12 ? "A" : "P",
        TT: H < 12 ? "AM" : "PM",
        Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
        o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
        S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
    }

    return mask.replace(token, function ($0) {
        return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1)
    })
}


const masks = {
    "default": "ddd mmm dd yyyy HH:MM:ss",
    shortDate: "m/d/yy",
    mediumDate: "mmm d, yyyy",
    longDate: "mmmm d, yyyy",
    fullDate: "dddd, mmmm d, yyyy",
    shortTime: "h:MM TT",
    mediumTime: "h:MM:ss TT",
    longTime: "h:MM:ss TT Z",
    isoDate: "yyyy-mm-dd",
    isoTime: "HH:MM:ss",
    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
}


const dayNames = [
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
]

const monthNames = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
]






export function escapeHtml(text) {
    if (!text) return ''

    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;')
}






export function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj
    }

    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item))
    }

    const cloned = {}
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            cloned[key] = deepClone(obj[key])
        }
    }

    return cloned
}

================
File: src/js/view/TrestleView.js
================
export class TrestleView {




    constructor(rootElement, eventBus) {

        this.rootElement = rootElement
        this.eventBus = eventBus
        this.template = document.getElementById('entry-template')
        this.nodeElements = new Map()
        this.selectedNodeId = null
        this.draggedNodeId = null
        this.dragTarget = null


        this.eventBus.subscribe('model:loaded', this.renderTree.bind(this))
        this.eventBus.subscribe('model:created', this.renderTree.bind(this))
        this.eventBus.subscribe('node:added', this.handleNodeAdded.bind(this))
        this.eventBus.subscribe('node:updated', this.handleNodeUpdated.bind(this))
        this.eventBus.subscribe('node:deleted', this.handleNodeDeleted.bind(this))
    }





    renderTree(data) {

        this.rootElement.innerHTML = ''
        this.nodeElements.clear()

        const rootNode = data.nodes.find(node => node.type === 'RootNode')
        if (!rootNode) {
            console.error('No root node found')

            return
        }


        const tree = this.buildTreeStructure(data.nodes, rootNode.id)


        const rootUl = document.createElement('ul')
        rootUl.className = 'ts-root'
        this.rootElement.appendChild(rootUl)


        for (const childId of tree.children || []) {
            this.renderNode(childId, rootUl, tree.nodes)
        }


        this.setupEventListeners()


        this.initDragAndDrop()
    }







    buildTreeStructure(nodes, rootId) {
        const nodesMap = new Map()


        for (const node of nodes) {
            nodesMap.set(node.id, { ...node })
        }


        for (const node of nodesMap.values()) {
            if (node.children) {

                node.children = node.children.filter(childId => nodesMap.has(childId))
            } else {
                node.children = []
            }
        }

        return {
            rootId,
            nodes: nodesMap
        }
    }








    renderNode(nodeId, parentElement, nodesMap) {
        const node = nodesMap.get(nodeId)
        if (!node) return null


        const li = document.createElement('li')
        li.dataset.nodeId = nodeId


        const dropzone = document.createElement('div')
        dropzone.className = 'dropzone'
        li.appendChild(dropzone)


        const entry = this.template.content.cloneNode(true).querySelector('.ts-entry')
        entry.id = nodeId


        const titleElement = entry.querySelector('.ts-title')
        titleElement.textContent = node.title || ''

        // Set created date (hidden)
        const dateElement = entry.querySelector('.date')
        dateElement.textContent = node.created || ''

        // Append entry to list item
        li.appendChild(entry)

        // Add to nodeElements map
        this.nodeElements.set(nodeId, li)

        // Render children if any
        if (node.children && node.children.length > 0) {
            const ul = document.createElement('ul')
            li.appendChild(ul)
            li.classList.add('ts-open')

            for (const childId of node.children) {
                this.renderNode(childId, ul, nodesMap)
            }
        } else {
            li.classList.add('ts-closed')
        }


        parentElement.appendChild(li)

        return li
    }




    setupEventListeners() {

        this.rootElement.addEventListener('click', this.handleClick.bind(this))
        this.rootElement.addEventListener('dblclick', this.handleDblClick.bind(this))
        this.rootElement.addEventListener('keydown', this.handleKeyDown.bind(this))


        this.rootElement.addEventListener('focus', this.handleFocus.bind(this), true)
        this.rootElement.addEventListener('blur', this.handleBlur.bind(this), true)
    }





    handleClick(event) {
        const target = event.target


        if (target.classList.contains('ts-expander')) {
            const li = target.closest('li')
            li.classList.toggle('ts-closed')
            li.classList.toggle('ts-open')
            event.stopPropagation()
            return
        }


        if (target.classList.contains('ts-card')) {
            this.showCard(target.closest('.ts-entry').id)
            event.stopPropagation()
            return
        }

        if (target.classList.contains('ts-addChild')) {
            const entryId = target.closest('.ts-entry').id
            this.eventBus.publish('view:addChild', { parentId: entryId })
            event.stopPropagation()
            return
        }

        if (target.classList.contains('ts-delete')) {
            const entryId = target.closest('.ts-entry').id
            if (confirm('Are you sure you want to delete this item and all its children?')) {
                this.eventBus.publish('view:deleteNode', { nodeId: entryId })
            }
            event.stopPropagation()
            return
        }


        if (target.classList.contains('ts-entry') || target.classList.contains('ts-title')) {
            const entry = target.classList.contains('ts-entry') ? target : target.closest('.ts-entry')
            this.selectNode(entry.id)
            event.stopPropagation()
            return
        }
    }





    handleDblClick(event) {
        const target = event.target


        if (target.classList.contains('ts-title')) {
            target.contentEditable = true
            target.focus()


            const range = document.createRange()
            range.selectNodeContents(target)
            const selection = window.getSelection()
            selection.removeAllRanges()
            selection.addRange(range)

            event.stopPropagation()
        }
    }





    handleKeyDown(event) {

        if (!event.target.isContentEditable) return

        const entry = event.target.closest('.ts-entry')
        if (!entry) return

        switch (event.key) {
            case 'Enter':
                if (!event.shiftKey) {

                    event.preventDefault()


                    event.target.contentEditable = false


                    const nodeId = entry.id
                    const newTitle = event.target.textContent.trim()
                    this.eventBus.publish('view:updateNode', { nodeId, properties: { title: newTitle } })


                    this.eventBus.publish('view:addSibling', { nodeId })
                }
                break

            case 'Tab':
                event.preventDefault()
                if (event.shiftKey) {

                    this.eventBus.publish('view:outdentNode', { nodeId: entry.id })
                } else {

                    this.eventBus.publish('view:indentNode', { nodeId: entry.id })
                }
                break

            case 'Escape':

                event.preventDefault()



                event.target.contentEditable = true
                this.selectNode(entry.id)
                break

            case 'ArrowUp':

                event.preventDefault()
                this.navigateUp(entry.id)
                break

            case 'ArrowDown':

                event.preventDefault()
                this.navigateDown(entry.id)
                break
        }
    }





    handleFocus(event) {
        if (event.target.classList.contains('ts-title')) {
            const entry = event.target.closest('.ts-entry')
            this.selectNode(entry.id)
        }
    }





    handleBlur(event) {
        if (event.target.classList.contains('ts-title') && event.target.isContentEditable) {



            const entry = event.target.closest('.ts-entry')
            const nodeId = entry.id
            const newTitle = event.target.textContent.trim()

            this.eventBus.publish('view:updateNode', { nodeId, properties: { title: newTitle } })
        }
    }




    initDragAndDrop() {

        const handles = this.rootElement.querySelectorAll('.ts-handle')
        handles.forEach(handle => {
            handle.addEventListener('mousedown', this.handleDragStart.bind(this))
            handle.setAttribute('draggable', 'true')
            handle.addEventListener('dragstart', this.handleDragStart.bind(this))
        })


        const dropzones = this.rootElement.querySelectorAll('.dropzone')
        dropzones.forEach(dropzone => {
            dropzone.addEventListener('dragover', this.handleDragOver.bind(this))
            dropzone.addEventListener('dragleave', this.handleDragLeave.bind(this))
            dropzone.addEventListener('drop', this.handleDrop.bind(this))
        })


        const items = this.rootElement.querySelectorAll('li')
        items.forEach(item => {
            item.addEventListener('dragenter', this.handleDragEnter.bind(this))
        })
    }





    handleDragStart(event) {
        const entry = event.target.closest('.ts-entry')
        if (!entry) return


        this.draggedNodeId = entry.id


        if (event.dataTransfer) {
            event.dataTransfer.setData('text/plain', entry.id)
            event.dataTransfer.effectAllowed = 'move'


            const dragImage = entry.cloneNode(true)
            dragImage.style.width = `${entry.offsetWidth}px`
            dragImage.style.opacity = '0.7'
            document.body.appendChild(dragImage)
            event.dataTransfer.setDragImage(dragImage, 10, 10)


            setTimeout(() => {
                document.body.removeChild(dragImage)
            }, 0)
        }


        entry.classList.add('ts-dragging')


        this.selectNode(entry.id)
    }





    handleDragOver(event) {

        event.preventDefault()

        if (!this.draggedNodeId) return


        event.target.classList.add('active')


        event.dataTransfer.dropEffect = 'move'
    }





    handleDragLeave(event) {

        event.target.classList.remove('active')
    }





    handleDragEnter(event) {
        const li = event.target.closest('li')
        if (!li || !this.draggedNodeId) return


        this.dragTarget = li


        li.classList.add('ts-highlight')


        if (this.dragEnterTimer) {
            clearTimeout(this.dragEnterTimer)
        }


        this.dragEnterTimer = setTimeout(() => {
            if (li.classList.contains('ts-closed')) {
                li.classList.remove('ts-closed')
                li.classList.add('ts-open')
            }
        }, 700)
    }





    handleDrop(event) {

        event.preventDefault()


        const dropzone = event.target
        dropzone.classList.remove('active')

        if (!this.draggedNodeId) return

        const draggedLi = this.nodeElements.get(this.draggedNodeId)
        if (!draggedLi) return


        const targetLi = dropzone.closest('li')
        if (!targetLi) return


        if (draggedLi.contains(targetLi)) {
            console.warn('Cannot drop onto a child element')
            return
        }


        const parentUl = targetLi.parentElement


        const isDropAfter = dropzone === targetLi.querySelector('.dropzone')

        let newParentId
        let newIndex

        if (isDropAfter) {

            newParentId = targetLi.parentElement.closest('li')?.dataset.nodeId || 'trestle-root'


            const siblings = Array.from(parentUl.children)
            newIndex = siblings.indexOf(targetLi)
        } else {

            newParentId = targetLi.dataset.nodeId


            let childUl = targetLi.querySelector('ul')
            if (!childUl) {
                childUl = document.createElement('ul')
                targetLi.appendChild(childUl)
                targetLi.classList.remove('ts-closed')
                targetLi.classList.add('ts-open')
            }


            newIndex = childUl.children.length
        }


        this.eventBus.publish('view:moveNode', {
            nodeId: this.draggedNodeId,
            newParentId: newParentId,
            newIndex: newIndex
        })


        this.draggedNodeId = null
        draggedLi.classList.remove('ts-dragging')


        document.querySelectorAll('.ts-highlight').forEach(el => {
            el.classList.remove('ts-highlight')
        })
    }





    selectNode(nodeId) {

        if (this.selectedNodeId) {
            const prevSelected = document.getElementById(this.selectedNodeId)
            if (prevSelected) {
                prevSelected.classList.remove('ts-selected')


                const prevTitle = prevSelected.querySelector('.ts-title')
                if (prevTitle) {

                }
            }
        }


        this.selectedNodeId = nodeId
        const entry = document.getElementById(nodeId)
        if (entry) {
            entry.classList.add('ts-selected')
        }
    }





    navigateUp(currentNodeId) {
        const currentLi = this.nodeElements.get(currentNodeId)
        if (!currentLi) return


        let prevLi = currentLi.previousElementSibling

        if (prevLi) {

            while (prevLi.classList.contains('ts-open') && prevLi.querySelector('ul')?.lastElementChild) {
                prevLi = prevLi.querySelector('ul').lastElementChild
            }


            const prevId = prevLi.querySelector('.ts-entry').id
            this.selectNode(prevId)
        } else {

            const parentLi = currentLi.parentElement.closest('li')
            if (parentLi) {
                const parentId = parentLi.querySelector('.ts-entry').id
                this.selectNode(parentId)
            }
        }
    }





    navigateDown(currentNodeId) {
        const currentLi = this.nodeElements.get(currentNodeId)
        if (!currentLi) return


        if (currentLi.classList.contains('ts-open')) {
            const firstChild = currentLi.querySelector('ul > li')
            if (firstChild) {
                const childId = firstChild.querySelector('.ts-entry').id
                this.selectNode(childId)
                return
            }
        }


        let nextLi = currentLi.nextElementSibling
        if (nextLi) {
            const nextId = nextLi.querySelector('.ts-entry').id
            this.selectNode(nextId)
            return
        }


        let parent = currentLi.parentElement.closest('li')
        while (parent) {
            const parentNext = parent.nextElementSibling
            if (parentNext) {
                const nextId = parentNext.querySelector('.ts-entry').id
                this.selectNode(nextId)
                return
            }
            parent = parent.parentElement.closest('li')
        }
    }





    showCard(nodeId) {

        const entry = document.getElementById(nodeId)
        if (!entry) return


        const title = entry.querySelector('.ts-title').textContent
        const date = entry.querySelector('.date').textContent


        this.eventBus.publish('view:getNodeData', {
            nodeId,
            callback: (node) => {
                const card = document.getElementById('card')
                const cardTitle = document.getElementById('card-title')
                const cardNid = document.getElementById('card-nid')
                const cardDate = document.getElementById('card-date')
                const cardDescription = document.getElementById('card-description')


                cardTitle.textContent = title
                cardNid.textContent = nodeId
                cardDate.textContent = date


                cardDescription.value = node.description || ''

                // Store node ID with the card
                card.dataset.nodeId = nodeId

                // Show the card
                card.classList.remove('hidden')


                cardDescription.focus()
            }
        })
    }





    handleNodeAdded(data) {
        const { node, parentId } = data


        let parentElement
        if (parentId === 'trestle-root') {
            parentElement = this.rootElement.querySelector('ul')
        } else {
            const parentLi = this.nodeElements.get(parentId)
            if (!parentLi) {
                console.error('Parent not found:', parentId)
                return
            }


            let ul = parentLi.querySelector('ul')
            if (!ul) {
                ul = document.createElement('ul')
                parentLi.appendChild(ul)
                parentLi.classList.remove('ts-closed')
                parentLi.classList.add('ts-open')
            }

            parentElement = ul
        }


        const nodesMap = new Map()
        nodesMap.set(node.id, node)


        const newNodeElement = this.renderNode(node.id, parentElement, nodesMap)


        if (newNodeElement) {
            const titleElement = newNodeElement.querySelector('.ts-title')
            this.selectNode(node.id)


            titleElement.contentEditable = true
            titleElement.focus()


            const range = document.createRange()
            range.selectNodeContents(titleElement)
            const selection = window.getSelection()
            selection.removeAllRanges()
            selection.addRange(range)
        }


        this.initDragAndDrop()
    }





    handleNodeUpdated(data) {
        const { nodeId, properties } = data


        const nodeEntry = document.getElementById(nodeId)
        if (!nodeEntry) return


        if (properties.title !== undefined) {
            const titleElement = nodeEntry.querySelector('.ts-title')
            titleElement.textContent = properties.title
        }


    }





    handleNodeDeleted(data) {
        const { nodeId } = data


        const nodeLi = this.nodeElements.get(nodeId)
        if (nodeLi) {
            nodeLi.remove()
            this.nodeElements.delete(nodeId)
        }
    }
}

================
File: src/js/workers/turtleSerializer.js
================
import rdf from 'rdf-ext'
import N3Parser from '@rdfjs/parser-n3'
import TurtleSerializer from '@rdfjs/serializer-turtle'
import { Readable } from 'readable-stream'


self.postMessage({ ready: true })

self.addEventListener('message', (event) => {
    const nquadsData = event.data

    if (typeof nquadsData !== 'string') {

        if (nquadsData && nquadsData.type === 'webpack-internal') return
        self.postMessage({ error: 'Invalid data received by worker. Expected N-Quads string.' })
        return
    }

    if (nquadsData.length === 0) {
        self.postMessage({ turtle: '' }) // Handle empty input
        return
    }

    try {
        const parser = new N3Parser({ factory: rdf })
        const serializer = new TurtleSerializer()
        let turtleString = ''

        // Create a readable stream from the N-Quads string
        const nquadsStream = new Readable()
        nquadsStream.push(nquadsData)
        nquadsStream.push(null)

        // Parse N-Quads
        const quadStream = parser.import(nquadsStream)

        // Serialize to Turtle
        const turtleStream = serializer.import(quadStream)

        turtleStream.on('data', (chunk) => {
            turtleString += chunk.toString()
        })

        turtleStream.on('end', () => {
            self.postMessage({ turtle: turtleString })
        })

        turtleStream.on('error', (err) => {
            console.error('Worker stream error:', err)
            self.postMessage({ error: `Serialization failed: ${err.message || err}` })
        })

    } catch (error) {
        console.error('Worker error during serialization setup:', error)
        self.postMessage({ error: `Serialization setup failed: ${error.message || error}` })
    }
})

================
File: src/js/config.js
================
export const Config = {


    SPARQL_ENDPOINT: 'https://fuseki.hyperdata.it/farelo',

    BASE_URI: 'http://hyperdata.it/trestle/',



    PREFIXES: {
        dc: 'http://purl.org/dc/terms/',
        ts: 'http://purl.org/stuff/trestle/'
    },


    AUTO_SAVE: false,
    AUTO_SAVE_INTERVAL: 60000,


    KEY_CODES: {
        TAB: 9,
        ENTER: 13,
        ESCAPE: 27,
        UP: 38,
        DOWN: 40
    }
}

================
File: src/js/main.js
================
import { TrestleModel } from './model/TrestleModel.js'
import { TrestleView } from './view/TrestleView.js'
import { TrestleController } from './controller/TrestleController.js'
import { Config } from './config.js'
import { EventBus } from './utils/EventBus.js'
import TrestleRDFModel from './model/TrestleRDFModel.js'

document.addEventListener('DOMContentLoaded', () => {

    const eventBus = new EventBus()


    const model = new TrestleRDFModel(Config.SPARQL_ENDPOINT, Config.BASE_URI, eventBus)
    const view = new TrestleView(document.getElementById('trestle-root'), eventBus)
    const controller = new TrestleController(model, view, eventBus)


    setupUIListeners(controller, model)


    controller.initialize()
})






function setupUIListeners(controller, model) {
    const saveButton = document.getElementById('saveButton')
    const addButton = document.getElementById('addButton')
    const shortcutsButton = document.getElementById('shortcutsButton')
    const debugButton = document.getElementById('debugButton')
    const cardClose = document.getElementById('card-close')
    const shortcutsText = document.getElementById('shortcuts-text')
    const debugOutput = document.getElementById('debug-output')
    const debugOutputArea = document.getElementById('debug-output-area')
    const debugCloseButton = document.getElementById('debug-close')


    const hamburgerButton = document.getElementById('hamburgerButton')
    const menuBox = document.getElementById('menu-box')


    if (saveButton) {
        saveButton.addEventListener('click', () => controller.saveData())
    }

    if (addButton) {
        addButton.addEventListener('click', () => controller.addRootItem())
    }

    if (shortcutsButton) {
        shortcutsButton.addEventListener('click', () => {
            if (shortcutsText) {
                shortcutsText.classList.toggle('hidden')
            }
        })
    }


    if (debugButton && debugOutput && debugOutputArea && model) {
        debugButton.addEventListener('click', async () => {

            debugButton.disabled = true
            debugButton.textContent = 'Loading...'
            debugOutputArea.value = 'Loading RDF data...'
            debugOutput.classList.remove('hidden')

            try {

                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Timeout: Serialization took too long')), 8000)
                })


                const turtleData = await Promise.race([
                    model.toTurtle(),
                    timeoutPromise
                ])

                debugOutputArea.value = turtleData
                console.log('Displayed RDF Model (Turtle)')
            } catch (error) {
                console.error('Error generating or displaying Turtle:', error)
                debugOutputArea.value = `Error generating Turtle representation:\n${error}`
            } finally {

                debugButton.disabled = false
                debugButton.textContent = 'Debug'
            }
        })
    }

    if (debugCloseButton && debugOutput) {
        debugCloseButton.addEventListener('click', () => {
            debugOutput.classList.add('hidden')
        })
    }


    if (hamburgerButton && menuBox) {
        hamburgerButton.addEventListener('click', (event) => {
            menuBox.classList.toggle('hidden')
            event.stopPropagation()
        })
    }


    if (menuBox) {
        document.addEventListener('click', (event) => {
            if (!menuBox.classList.contains('hidden') &&
                !menuBox.contains(event.target) &&
                event.target !== hamburgerButton) {
                menuBox.classList.add('hidden')
            }
        })
    }


    if (cardClose) {
        cardClose.addEventListener('click', () => {
            const card = document.getElementById('card')
            const cardDescription = document.getElementById('card-description')


            if (card && card.dataset.nodeId) {
                controller.updateNodeDescription(card.dataset.nodeId, cardDescription.value)
            }

            card.classList.add('hidden')
        })
    }
}

================
File: src/utils/utils.js
================
export const namespaces = {
    rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
    xsd: 'http://www.w3.org/2001/XMLSchema#',
    dc: 'http://purl.org/dc/terms/',
    foaf: 'http://xmlns.com/foaf/0.1/',
    squirt: 'http://purl.org/stuff/squirt#',
    ts: 'http://purl.org/stuff/trestle#'
}





export function generateID() {
    const now = new Date()
    const timestamp = formatDate(now, "yyyy-mm-dd-HH-MM-ss-l")
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0')
    return `${timestamp}-${random}`
}





export function generateDate() {
    return new Date().toISOString()
}






export function generateNid(content) {

    let hash = 0
    if (content.length === 0) return 'nid-' + generateID()

    for (let i = 0; i < content.length; i++) {
        const char = content.charCodeAt(i)
        hash = ((hash << 5) - hash) + char
        hash = hash & hash
    }


    hash = Math.abs(hash)

    return 'nid-' + hash.toString(16) + '-' + Date.now().toString(36)
}








export function formatDate(date, mask, utc = true) {
    const token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g
    const timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g
    const timezoneClip = /[^-+\dA-Z]/g

    const pad = (val, len) => {
        val = String(val)
        len = len || 2
        while (val.length < len) val = "0" + val
        return val
    }


    if (arguments.length === 1 && Object.prototype.toString.call(date) === "[object String]" && !/\d/.test(date)) {
        mask = date
        date = undefined
    }


    date = date ? new Date(date) : new Date()
    if (isNaN(date)) throw SyntaxError("invalid date")

    mask = String(masks[mask] || mask || masks["default"])


    if (mask.slice(0, 4) === "UTC:") {
        mask = mask.slice(4)
        utc = true
    }

    const _ = utc ? "getUTC" : "get"
    const d = date[_ + "Date"]()
    const D = date[_ + "Day"]()
    const m = date[_ + "Month"]()
    const y = date[_ + "FullYear"]()
    const H = date[_ + "Hours"]()
    const M = date[_ + "Minutes"]()
    const s = date[_ + "Seconds"]()
    const L = date[_ + "Milliseconds"]()
    const o = utc ? 0 : date.getTimezoneOffset()

    const flags = {
        d: d,
        dd: pad(d),
        ddd: dayNames[D],
        dddd: dayNames[D + 7],
        m: m + 1,
        mm: pad(m + 1),
        mmm: monthNames[m],
        mmmm: monthNames[m + 12],
        yy: String(y).slice(2),
        yyyy: y,
        h: H % 12 || 12,
        hh: pad(H % 12 || 12),
        H: H,
        HH: pad(H),
        M: M,
        MM: pad(M),
        s: s,
        ss: pad(s),
        l: pad(L, 3),
        L: pad(L > 99 ? Math.round(L / 10) : L),
        t: H < 12 ? "a" : "p",
        tt: H < 12 ? "am" : "pm",
        T: H < 12 ? "A" : "P",
        TT: H < 12 ? "AM" : "PM",
        Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
        o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
        S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
    }

    return mask.replace(token, function ($0) {
        return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1)
    })
}




const masks = {
    "default": "ddd mmm dd yyyy HH:MM:ss",
    shortDate: "m/d/yy",
    mediumDate: "mmm d, yyyy",
    longDate: "mmmm d, yyyy",
    fullDate: "dddd, mmmm d, yyyy",
    shortTime: "h:MM TT",
    mediumTime: "h:MM:ss TT",
    longTime: "h:MM:ss TT Z",
    isoDate: "yyyy-mm-dd",
    isoTime: "HH:MM:ss",
    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
}




const dayNames = [
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
]




const monthNames = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
]






export function escapeHtml(text) {
    if (!text) return ''

    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;')
}






export function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj
    }

    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item))
    }

    const cloned = {}
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            cloned[key] = deepClone(obj[key])
        }
    }

    return cloned
}

================
File: test/unit/TrestleModel.spec.js
================
import { expect } from 'chai'
import { EventBus } from '../../src/js/utils/EventBus.js'
import { TrestleModel } from '../../src/js/model/TrestleModel.js'
import { JSDOM } from 'jsdom'


const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>')
global.window = dom.window
global.document = dom.window.document

describe('TrestleModel', () => {
    let model
    let eventBus
    let mockEndpoint = 'http://mock-endpoint/sparql'
    let mockBaseUri = 'http://example.org/trestle/'

    beforeEach(() => {
        eventBus = new EventBus()


        global.fetch = async () => ({
            ok: true,
            json: async () => ({ results: { bindings: [] } })
        })


        model = new TrestleModel(mockEndpoint, mockBaseUri, eventBus)
    })

    afterEach(() => {
        delete global.fetch
    })

    describe('initialization', () => {
        it('should initialize with model:loaded event', async () => {
            let loadedCalled = false
            eventBus.subscribe('model:loaded', () => {
                loadedCalled = true
            })

            await model.initialize()

            expect(loadedCalled).to.be.true
        })


        it('should initialize nodes map when loaded', async () => {

            await model.initialize()


            expect(model.nodes).to.exist

        })
    })

    describe('CRUD operations', () => {
        beforeEach(async () => {
            await model.initialize()

            if (!model.rootId) {
                model.createEmptyModel()
            }
        })

        it('should add node correctly', () => {
            const rootId = model.rootId
            expect(rootId).to.exist

            const newNode = model.addNode(rootId, 'Test Node', 0)

            expect(newNode).to.exist
            expect(newNode.title).to.equal('Test Node')
            expect(newNode.parent).to.equal(rootId)
            expect(newNode.index).to.equal(0)

            const rootNode = model.getNode(rootId)
            expect(rootNode.children).to.include(newNode.id)
        })

        it('should update node correctly', () => {
            const rootId = model.rootId
            const newNode = model.addNode(rootId, 'Test Node', 0)

            model.updateNode(newNode.id, { title: 'Updated Title' })

            const updatedNode = model.getNode(newNode.id)
            expect(updatedNode.title).to.equal('Updated Title')
        })

        it('should delete node correctly', () => {
            const rootId = model.rootId
            const newNode = model.addNode(rootId, 'Test Node', 0)

            model.deleteNode(newNode.id)

            const deletedNode = model.getNode(newNode.id)
            expect(deletedNode).to.be.undefined

            const rootNode = model.getNode(rootId)
            expect(rootNode.children).to.not.include(newNode.id)
        })

        it('should delete node and all its children', () => {
            const rootId = model.rootId
            const parentNode = model.addNode(rootId, 'Parent Node', 0)
            const childNode = model.addNode(parentNode.id, 'Child Node', 0)

            model.deleteNode(parentNode.id)

            expect(model.getNode(parentNode.id)).to.be.undefined
            expect(model.getNode(childNode.id)).to.be.undefined
        })
    })

    describe('Hierarchical operations', () => {
        let rootId, node1, node2, node3

        beforeEach(async () => {
            await model.initialize()
            if (!model.rootId) {
                model.createEmptyModel()
            }
            rootId = model.rootId
            node1 = model.addNode(rootId, 'Node 1', 0)
            node2 = model.addNode(rootId, 'Node 2', 1)
            node3 = model.addNode(rootId, 'Node 3', 2)
        })

        it('should move node to a new parent', () => {
            model.moveNode(node3.id, node1.id, 0)

            const updatedNode3 = model.getNode(node3.id)
            expect(updatedNode3.parent).to.equal(node1.id)
            expect(updatedNode3.index).to.equal(0)

            const updatedNode1 = model.getNode(node1.id)
            expect(updatedNode1.children).to.include(node3.id)

            const rootNode = model.getNode(rootId)
            expect(rootNode.children).to.not.include(node3.id)
        })

        it('should reorder nodes within the same parent', () => {
            model.moveNode(node3.id, rootId, 0)

            const updatedRoot = model.getNode(rootId)
            expect(updatedRoot.children[0]).to.equal(node3.id)
            expect(updatedRoot.children[1]).to.equal(node1.id)
            expect(updatedRoot.children[2]).to.equal(node2.id)

            expect(model.getNode(node3.id).index).to.equal(0)
            expect(model.getNode(node1.id).index).to.equal(1)
            expect(model.getNode(node2.id).index).to.equal(2)
        })
    })

    describe('RDF serialization', () => {
        beforeEach(async () => {
            await model.initialize()
            if (!model.rootId) {
                model.createEmptyModel()
            }
            const rootId = model.rootId
            model.addNode(rootId, 'Test Node 1', 0)
            const node2 = model.addNode(rootId, 'Test Node 2', 1)
            model.addNode(node2.id, 'Child Node', 0)
        })

        it('should generate valid Turtle representation', () => {
            const turtle = model.toTurtle()

            expect(turtle).to.include('@prefix dc:')
            expect(turtle).to.include('@prefix ts:')
            expect(turtle).to.include('a ts:RootNode')
            expect(turtle).to.include('a ts:Node')
            expect(turtle).to.include('dc:title "Test Node 1"')
            expect(turtle).to.include('dc:title "Test Node 2"')
            expect(turtle).to.include('dc:title "Child Node"')
            expect(turtle).to.include('ts:index "0"')
            expect(turtle).to.include('ts:parent')
        })

        it('should escape special characters in Turtle strings', () => {
            const rootId = model.rootId
            model.addNode(rootId, 'Node with "quotes" and \\ backslash', 2)

            const turtle = model.toTurtle()

            expect(turtle).to.include('dc:title "Node with \\"quotes\\" and \\\\ backslash"')
        })
    })

    describe('Event handling', () => {
        beforeEach(async () => {
            await model.initialize()
            if (!model.rootId) {
                model.createEmptyModel()
            }
        })

        it('should handle node:updated events', () => {
            const rootId = model.rootId
            const node = model.addNode(rootId, 'Original Title', 0)

            eventBus.publish('node:updated', {
                nodeId: node.id,
                properties: { title: 'Updated via Event' }
            })

            const updatedNode = model.getNode(node.id)
            expect(updatedNode.title).to.equal('Updated via Event')
        })

        it('should handle node:moved events', () => {
            const rootId = model.rootId
            const node1 = model.addNode(rootId, 'Node 1', 0)
            const node2 = model.addNode(rootId, 'Node 2', 1)

            eventBus.publish('node:moved', {
                nodeId: node2.id,
                newParentId: node1.id,
                newIndex: 0
            })

            const movedNode = model.getNode(node2.id)
            expect(movedNode.parent).to.equal(node1.id)

            const parentNode = model.getNode(node1.id)
            expect(parentNode.children).to.include(node2.id)
        })

        it('should handle node:deleted events', () => {
            const rootId = model.rootId
            const node = model.addNode(rootId, 'Node to Delete', 0)

            eventBus.publish('node:deleted', {
                nodeId: node.id
            })

            expect(model.getNode(node.id)).to.be.undefined

            const rootNode = model.getNode(rootId)
            expect(rootNode.children).to.not.include(node.id)
        })
    })
})

================
File: test/unit/TrestleRDFModel.spec.js
================
import { expect } from 'chai'
import { EventBus } from '../../src/js/utils/EventBus.js'
import TrestleRDFModel from '../../src/js/model/TrestleRDFModel.js'
import { JSDOM } from 'jsdom'


const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>')
global.window = dom.window
global.document = dom.window.document

describe('TrestleRDFModel', () => {
    let model
    let eventBus
    let mockEndpoint = 'http://mock-endpoint/sparql'
    let mockBaseUri = 'http://example.org/trestle/'

    beforeEach(() => {
        eventBus = new EventBus()


        global.fetch = async () => ({
            ok: true,
            json: async () => ({ results: { bindings: [] } })
        })


        model = new TrestleRDFModel(mockEndpoint, mockBaseUri, eventBus)
    })

    afterEach(() => {
        delete global.fetch
    })

    describe('initialization', () => {
        it('should initialize with an RDF dataset', async () => {
            await model.initialize()
            model.createEmptyModel()

            expect(model.rdfDataset).to.exist


            const rootId = model.rootId
            expect(rootId).to.exist


            const quads = Array.from(model.rdfDataset)
            expect(quads.length).to.be.at.least(1)


            const rootQuads = quads.filter(quad =>
                quad.subject.value.includes(rootId)
            )
            expect(rootQuads.length).to.be.at.least(1)
        })
    })

    describe('CRUD operations with RDF', () => {
        beforeEach(async () => {
            await model.initialize()
            model.createEmptyModel()
        })

        it('should add node with RDF representation', () => {
            const rootId = model.rootId
            const newNode = model.addNode(rootId, 'Test Node', 0)


            expect(newNode).to.exist
            expect(newNode.title).to.equal('Test Node')


            const quads = Array.from(model.rdfDataset)
            const nodeQuads = quads.filter(quad =>
                quad.subject.value.includes(newNode.id)
            )

            expect(nodeQuads.length).to.be.at.least(1)


            const titleQuad = nodeQuads.find(quad =>
                quad.predicate.value.includes('title')
            )
            expect(titleQuad).to.exist
            expect(titleQuad.object.value).to.equal('Test Node')


            const parentQuad = nodeQuads.find(quad =>
                quad.predicate.value.includes('parent')
            )
            expect(parentQuad).to.exist
            expect(parentQuad.object.value).to.include(rootId)
        })

        it('should update node with RDF representation', () => {
            const rootId = model.rootId
            const newNode = model.addNode(rootId, 'Original Title', 0)


            model.updateNode(newNode.id, { title: 'Updated Title' })


            const updatedNode = model.getNode(newNode.id)
            expect(updatedNode.title).to.equal('Updated Title')


            const quads = Array.from(model.rdfDataset)
            const titleQuad = quads.find(quad =>
                quad.subject.value.includes(newNode.id) &&
                quad.predicate.value.includes('title')
            )

            expect(titleQuad).to.exist
            expect(titleQuad.object.value).to.equal('Updated Title')
        })

        it('should delete node with RDF representation', () => {
            const rootId = model.rootId
            const newNode = model.addNode(rootId, 'Node to Delete', 0)


            let quads = Array.from(model.rdfDataset)
            let nodeQuads = quads.filter(quad =>
                quad.subject.value.includes(newNode.id)
            )
            expect(nodeQuads.length).to.be.at.least(1)


            model.deleteNode(newNode.id)


            expect(model.getNode(newNode.id)).to.be.undefined


            quads = Array.from(model.rdfDataset)
            nodeQuads = quads.filter(quad =>
                quad.subject.value.includes(newNode.id)
            )
            expect(nodeQuads.length).to.equal(0)
        })

        it('should delete node and all its children from RDF', () => {
            const rootId = model.rootId
            const parentNode = model.addNode(rootId, 'Parent Node', 0)
            const childNode = model.addNode(parentNode.id, 'Child Node', 0)


            let quads = Array.from(model.rdfDataset)
            let parentQuads = quads.filter(quad =>
                quad.subject.value.includes(parentNode.id)
            )
            let childQuads = quads.filter(quad =>
                quad.subject.value.includes(childNode.id)
            )

            expect(parentQuads.length).to.be.at.least(1)
            expect(childQuads.length).to.be.at.least(1)


            model.deleteNode(parentNode.id)


            expect(model.getNode(parentNode.id)).to.be.undefined
            expect(model.getNode(childNode.id)).to.be.undefined


            quads = Array.from(model.rdfDataset)
            parentQuads = quads.filter(quad =>
                quad.subject.value.includes(parentNode.id)
            )
            childQuads = quads.filter(quad =>
                quad.subject.value.includes(childNode.id)
            )

            expect(parentQuads.length).to.equal(0)
            expect(childQuads.length).to.equal(0)
        })

        it('should update node description in RDF', () => {
            const rootId = model.rootId
            const newNode = model.addNode(rootId, 'Node with Description', 0)


            model.updateNodeDescription(newNode.id, 'Test description')


            const updatedNode = model.getNode(newNode.id)
            expect(updatedNode.description).to.equal('Test description')


            const quads = Array.from(model.rdfDataset)
            const descQuad = quads.find(quad =>
                quad.subject.value.includes(newNode.id) &&
                quad.predicate.value.includes('description')
            )

            expect(descQuad).to.exist
            expect(descQuad.object.value).to.equal('Test description')
        })
    })

    describe('Hierarchical operations with RDF', () => {
        let rootId, node1, node2, node3

        beforeEach(async () => {
            await model.initialize()
            model.createEmptyModel()
            rootId = model.rootId
            node1 = model.addNode(rootId, 'Node 1', 0)
            node2 = model.addNode(rootId, 'Node 2', 1)
            node3 = model.addNode(rootId, 'Node 3', 2)
        })

        it('should update RDF when moving nodes', () => {

            model.moveNode(node3.id, node1.id, 0)


            const updatedNode3 = model.getNode(node3.id)
            expect(updatedNode3.parent).to.equal(node1.id)


            const quads = Array.from(model.rdfDataset)


            const parentQuad = quads.find(quad =>
                quad.subject.value.includes(node3.id) &&
                quad.predicate.value.includes('parent')
            )

            expect(parentQuad).to.exist
            expect(parentQuad.object.value).to.include(node1.id)


            const indexQuad = quads.find(quad =>
                quad.subject.value.includes(node3.id) &&
                quad.predicate.value.includes('index')
            )

            expect(indexQuad).to.exist
            expect(indexQuad.object.value).to.equal('0')
        })
    })

    describe('RDF dataset operations', () => {
        beforeEach(async () => {
            await model.initialize()
            model.createEmptyModel()
        })

        it('should provide access to the RDF dataset', () => {
            const rootId = model.rootId
            model.addNode(rootId, 'Test Node', 0)

            const dataset = model.getRDFDataset()
            expect(dataset).to.exist

            const quads = Array.from(dataset)
            expect(quads.length).to.be.at.least(2)
        })

        it('should generate Turtle output', () => {
            const rootId = model.rootId
            model.addNode(rootId, 'Test Node 1', 0)
            const node2 = model.addNode(rootId, 'Test Node 2', 1)
            model.addNode(node2.id, 'Child Node', 0)

            const turtle = model.toTurtle()

            expect(turtle).to.include('@prefix dc:')
            expect(turtle).to.include('@prefix ts:')
            expect(turtle).to.include('a ts:RootNode')
            expect(turtle).to.include('a ts:Node')
            expect(turtle).to.include('dc:title "Test Node 1"')
            expect(turtle).to.include('dc:title "Test Node 2"')
            expect(turtle).to.include('dc:title "Child Node"')
        })
    })
})

================
File: jasmine.json
================
{
    "spec_dir": "test",
    "spec_files": [
        "**/*[sS]pec.js"
    ],
    "helpers": [],
    "stopSpecOnExpectationFailure": true,
    "random": false
}

================
File: jsdoc.json
================
{
  "tags": {
    "allowUnknownTags": true,
    "dictionaries": ["jsdoc", "closure"]
  },
  "source": {
    "include": ["js", "README.md"],
    "exclude": ["node_modules"],
    "includePattern": ".+\\.js(doc|x)?$",
    "excludePattern": "(^|\\/|\\\\)_"
  },
  "plugins": [
    "plugins/markdown"
  ],
  "templates": {
    "cleverLinks": false,
    "monospaceLinks": false,
    "default": {
      "outputSourceFiles": true,
      "includeDate": false
    }
  },
  "opts": {
    "destination": "./docs/jsdoc",
    "encoding": "utf8",
    "recurse": true,
    "template": "node_modules/docdash"
  }
}

================
File: package.json
================
{
  "name": "trestle",
  "version": "0.9.0",
  "description": "A hierarchical todo list with SPARQL backend",
  "type": "module",
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack serve --mode development",
    "test": "jasmine --config=jasmine.json",
    "docs": "jsdoc -c jsdoc.json",
    "rp": "repomix -c repomix.config.json ."
  },
  "keywords": [
    "todo",
    "rdf",
    "sparql",
    "outliner",
    "hierarchical"
  ],
  "author": "Danny Ayers",
  "license": "MIT",
  "dependencies": {
    "@rdfjs/data-model": "^2.0.1",
    "@rdfjs/namespace": "^2.0.0",
    "@rdfjs/parser-n3": "^2.0.1",
    "loglevel": "^1.8.1",
    "marked": "^5.0.0",
    "rdf-ext": "^2.2.0"
  },
  "devDependencies": {
    "@rdfjs/serializer-turtle": "^1.1.5",
    "chai": "^4.5.0",
    "copy-webpack-plugin": "^13.0.0",
    "html-webpack-plugin": "^5.6.3",
    "jasmine": "^4.6.0",
    "jsdoc": "^4.0.2",
    "jsdom": "^26.1.0",
    "readable-stream": "^4.7.0",
    "stream-to-string": "^1.2.1",
    "webpack": "^5.89.0",
    "webpack-cli": "^5.1.4",
    "webpack-dev-server": "^4.15.2"
  }
}

================
File: README.md
================
# Trestle - Modern Hierarchical Todo List

Trestle is a web-based hierarchical todo list application with RDF/SPARQL backend support. It allows you to create, organize, and manage nested tasks with rich text descriptions using markdown.

## Features

- **Hierarchical Structure**: Organize tasks in a tree-like structure with unlimited nesting
- **Drag and Drop**: Easily reorganize tasks by dragging and dropping
- **Keyboard Navigation**: Navigate and edit using keyboard shortcuts
- **Markdown Support**: Write rich task descriptions using markdown
- **SPARQL Backend**: Store your data in a standard RDF triplestore
- **Card View**: View and edit detailed information for each task
- **Responsive Design**: Works on both desktop and mobile devices

## Getting Started

### Prerequisites

- Node.js 16 or later
- A SPARQL endpoint (like Apache Jena Fuseki) for data storage

### Installation

1. Clone the repository:

   ```bash
   git clone https://github.com/yourusername/trestle.git
   cd trestle
   ```

2. Install dependencies:

   ```bash
   npm install
   ```

3. Configure the application:

   - Edit `js/config.js` to set your SPARQL endpoint URL and other preferences

4. Start the development server:

   ```bash
   npm run dev
   ```

5. Build for production:
   ```bash
   npm run build
   ```

## Usage

### Keyboard Shortcuts

- **Enter**: Create a new sibling item
- **Tab**: Indent (make a child of previous item)
- **Shift+Tab**: Outdent (move to parent level)
- **Up/Down**: Navigate through items
- **Click** on an item to select it
- **Double-click** on an item to edit it

### Card View

Click the card icon (📄) next to any item to open its detail card. Here you can add and edit markdown descriptions.

### Drag and Drop

- Drag items using the handle (●) to reposition them
- Drop between items to place as a sibling
- Hold over an item to make the dragged item a child

## Data Model

Trestle uses RDF to represent the data structure with the following predicates:

- `dc:title`: Item title
- `dc:created`: Creation timestamp
- `dc:description`: Markdown description
- `ts:index`: Position in parent's children list
- `ts:parent`: Reference to parent node

## Development

### Project Structure

- `js/model/`: Data model and SPARQL interaction
- `js/view/`: UI rendering and event handling
- `js/controller/`: Application logic
- `js/utils/`: Utility functions and helpers

### Running Tests

```bash
npm test
```

### Generating Documentation

```bash
npm run docs
```

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgments

- Original Trestle concept by Danny Ayers
- Inspired by [Workflowy](https://workflowy.com)

================
File: webpack.config.js
================
import path from 'path'
import { fileURLToPath } from 'url'
import CopyWebpackPlugin from 'copy-webpack-plugin'
import HtmlWebpackPlugin from 'html-webpack-plugin'


const __dirname = path.dirname(fileURLToPath(import.meta.url))

export default {
    entry: './src/js/main.js',
    resolve: {
        extensions: ['.js', '.json'],
        alias: {
            '@': path.resolve(__dirname, 'src')
        }
    },
    output: {
        filename: '[name].bundle.js',
        chunkFilename: '[id].worker.js',
        path: path.resolve(__dirname, 'dist/public'),
        publicPath: '/',
        clean: true,
    },
    devServer: {
        static: {
            directory: path.resolve(__dirname, 'dist/public')
        },
        port: 9090,
        open: true,


    },
    plugins: [
        new HtmlWebpackPlugin({
            template: path.resolve(__dirname, 'src/html/index.html'),
            filename: 'index.html',
            inject: 'body'
        }),
        new CopyWebpackPlugin({
            patterns: [









                {

                    from: path.resolve(__dirname, 'src/css'),
                    to: path.resolve(__dirname, 'dist/public/css'),
                    globOptions: {
                        ignore: ['**/.*'],
                    },
                }
            ]
        })
    ],
    mode: 'development',
    devtool: 'inline-source-map',
}
